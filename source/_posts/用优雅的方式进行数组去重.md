---
title: 用优雅的方式进行数组去重
author: Tomatoro
comments: true
tags: [JavaScript,ES6]
top: 0
date: 2019-08-22 16:47:59
---

>想必,数组去重已经是一个老生常谈的问题了, 到现在为止我们要考虑的并不是怎么去实现一个数组去重, 而更应该关注,怎样使用一段更短的代码, 更优雅, 更简洁的达到我们想要的效果.

<!-- more -->

### 开篇
>我们这里直接列出三种比较优雅的数组去重的方法,在后面对每个进行详细的解析
```JS
const originalArray = [1, 2, '咩', 1, 'Super Ball', '咩', '咩', 'Super Ball', 4]

const bySet = [...new Set(originalArray)]

const byFilter = originalArray.filter((item, index) => originalArray.indexOf(item) === index)

const byReduce = originalArray.reduce((unique, item) => unique.includes(item) ? unique : [...unique, item], [])
```

### Set
先让我们来看看 `Set` 到底是个啥

> Set 对象允许你存储任何类型的唯一值，无论是原始值或者是对象引用。
> <cite>https://developer.mozilla.org...</cite>

首先， `Set` 中只允许出现唯一值
唯一性是比对原始值或者对象引用

`const bySet = [...new Set(originalArray)] `这一段的操作，我们将它拆分来看：
```JS
const originalArray = [1, 2, '咩', 1, 'Super Ball', '咩', '咩', 'Super Ball', 4]

const uniqueSet = new Set(originalArray)
// 得到 Set(5) [ 1, 2, "咩", "Super Ball", 4 ]

const bySet = [...uniqueSet]
// 得到 Array(5) [ 1, 2, "咩", "Super Ball", 4 ]
```

在将 `Set` 转为 `Array` 时，也可以使用 `Array.from(set)`。

### Array.prototype.filter
要理解 `filter` 方法为什么可以去重，需要关注一下另一个方法 `indexOf`

> indexOf()方法返回在数组中可以找到一个给定元素的第一个索引，如果不存在，则返回 -1。
> <cite>https://developer.mozilla.org...</cite>
```JS
const beasts = ['ant', 'bison', 'camel', 'duck', 'bison'];

console.log(beasts.indexOf('bison'));
// expected output: 1

// start from index 2
console.log(beasts.indexOf('bison', 2));
// expected output: 4

console.log(beasts.indexOf('giraffe'));
// expected output: -1
```
> filter() 方法创建一个新数组, 其包含通过所提供函数实现的测试的所有元素。
> <cite>https://developer.mozilla.org...</cite>

`filter` 方法接受两个参数：

1. 第一个参数：一个回调函数， `filter` 会将数据中的每一项都传递给该函数，若该函数返回 真值，则数据保存，返回 假值，则数据将不会出现在新生成的数据中
2. 第二个参数：回调函数中 `this` 的指向

我们将上面的去重方法按下面这样重写一下，就可以看清整个 `filter` 的执行过程了。
```JS
const originalArray = [1, 2, '咩', 1, 'Super Ball', '咩', '咩', 'Super Ball', 4]

const table = []

const byFilter = originalArray.filter((item, index) => {
  // 如果找到的索引与当前索引一致，则保留该值
  const shouldKeep = originalArray.indexOf(item) === index
  table.push({
    序号: index,
    值: item,
    是否应该保留: shouldKeep ? '保留' : '删除'
  })
  return shouldKeep
})

console.log(byFilter)
console.table(table)
```
序号|值|是否应该保留|出现
-----|-----|-----|-----
0	 |	1	 |	保留	 |	第一次出现
1	 |	2	 |	保留	 |	第一次出现
2	 |	咩	 |	保存	 |	第一次出现
3	 |	1	 |	删除	 |	第二次出现
4	 |	Super Ball	 |	保留	 |	第一次出现
5	 |	咩	 |	删除	 |	第二次出现
6	 |	咩	 |	删除	 |	第三次出现
7	 |	Super Ball	 |	删除	 |	第二次出现
8	 |	4	 |	保留	 |	第一次出现


### Array.prototype.reduce

> reduce() 方法对数组中的每个元素执行一个由您提供的 reducer 函数(升序执行)，将其结果汇总为单个返回值。
> <cite>https://developer.mozilla.org...</cite>

`Array.prototype.reduce` 方法接受两个参数：

- `Callback`：回调函数，它可以接收四个参数

- `Accumulator`：累计器，这个其实是让很多人忽略的一点，就是，累计器其实可以是任何类型的数据
	- `Current Value`：当前值
	- `Current Index`：当前值的索引
	- `Source Array`：源数组
	- `Initial Value`：累计器的初始值，就跟累计器一样，这个参数也总是被绝大多数人忽略

就像 filter 章节一样，我们来看看 reduce 的执行过程：
```JS
const originalArray = [1, 2, '咩', 1, 'Super Ball', '咩', '咩', 'Super Ball', 4]

const byReduce = originalArray.reduce((unique, item, index, source) => {
  const exist = unique.includes(item)
  const next = unique.includes(item) ? unique : [...unique, item]
  console.group(`遍历第 ${index} 个值`)
  console.log('当前累计器：', unique)
  console.log('当前值：', item)
  console.log('是否已添加进累计器？', exist)
  console.log('新值', next)
  console.groupEnd()
  return next
}, [])
```

