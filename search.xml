<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Hexo博客添加Valine评论功能全过程]]></title>
    <url>%2Farchives%2F736d3b08.html</url>
    <content type="text"><![CDATA[Hexo 可用的评论系统有很多，如下： 来必力：https://livere.com （需要邮箱注册，加载慢，较卡顿） 畅言： http://changyan.kuaizhan.com （安装需要备案号） Gitment： https://github.com/imsun/gitment （加载慢，有 Bug） Valine: https://github.com/xCss/Valine (简约，实用，使用 Leancloud 作为线上数据库） 评论系统配置过程next 集成了 leancloud 。可以在leancloud进行账号注册。 1、注册 LeanCloud注册地址 https://leancloud.cn/ 2、配置 LeanCloud创建一个新的应用 随便取个名字，自己看着取吧 应用创建完成，点开配置按钮 点击设置 &gt; 应用Key 复制 App ID 和 App Key 点击设置 &gt; 安全中心 把自己博客网址添加到安全中心，保证数据的调用安全。 代码部分One 1234567891011# Valinevaline: enable: true el: &apos;vcomments&apos; appId: &apos;&apos; # 你的appId appKey: &apos;&apos; # 你的appKey notify: true # 邮箱推送 verify: true avatar: &apos;mp&apos; pageSize: &apos;10&apos; placeholder: &apos;请输入...&apos; Two 找到你的主题中放评论的位置加上valine这一行就可以 Three 这个文件里填上这些内容 12345678910111213141516&lt;% if (theme.valine.enable) &#123; %&gt;&lt;div class=&quot;vcomments&quot; id=&quot;&lt;%- theme.valine.el %&gt;&quot;&gt;&lt;/div&gt;&lt;%- js(&apos;https://unpkg.com/valine/dist/Valine.min.js&apos;) %&gt;&lt;script&gt; new Valine(&#123; el: &apos;#&lt;%- theme.valine.el %&gt;&apos;, appId: &apos;&lt;%- theme.valine.appId %&gt;&apos;, appKey: &apos;&lt;%- theme.valine.appKey %&gt;&apos;, notify: &apos;&lt;%- theme.valine.notify %&gt;&apos;, verify: &apos;&lt;%- theme.valine.verify %&gt;&apos;, avatar: &apos;&lt;%- theme.valine.avatar %&gt;&apos;, pageSize: &apos;&lt;%- theme.valine.pageSize %&gt;&apos;, placeholder: &apos;&lt;%- theme.valine.placeholder %&gt;&apos; &#125;)&lt;/script&gt;&lt;% &#125; %&gt; ####Four 12.vcomments margin-top: 3rem ####Five 引入上面这个css文件]]></content>
      <tags>
        <tag>Blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端所有跨域方式实现原理及详解]]></title>
    <url>%2Farchives%2F5d00c70d.html</url>
    <content type="text"><![CDATA[跨域是我们在项目中经常遇到的，前后端数据交互经常碰到请求跨域，首先我们来想一下为什么会有跨域这个词的出现？本文带你来探讨一下以下几个问题： 跨域是什么？ 为什么要跨域？ 跨域的几种方式？ … 什么是跨域?跨域是指的浏览器不能执行其它网站的脚本，它是由浏览器的同源策略造成，是浏览器对 JavaScript 实施的安全限制。 跨域实际上指从一个域的网页去请求另一个域的资源，比如：从 http://www.baidu.com 网站去请求http://www.google.com 网站的资源。 什么是同源策略?同源策略 指的是 域名，协议，端口 三者都相同~ 什么是同源?要知道URL由协议，域名，端口以及路径组成，若两个URL的协议、域名和端口相同，则表示他们同源。相反，只要协议，域名，端口有任何一个的不同，就被当作是跨域。 限制同源策略内容 Cookie、LocalStorage、IndexedDB 等存储性内容 DOM 节点 Ajax 请求发送后，结果被浏览器拦截了 允许跨域加载资源这下边三个含有 src 标签的是允许跨域加载资源的 1&lt;img src=XXX&gt; 1&lt;link href=XXX&gt; 1&lt;script src=XXX&gt; 跨域的场景 九种跨域解决方案 jsonp cors postMessage document.domain window.name location.hash https-proxy nginx websocket jsonp什么是 jsonpjsonp全称是JSON with Padding，是为了解决跨域请求资源而产生的解决方案，是一种依赖开发人员创造出的一种非官方跨域数据交互协议。 Jsonp 的原理 利用 script 标签的 src 属性来实现跨域 通过将前端方法作为参数传递到服务器端，然后由服务器端注入参数之后再返回，实现服务器端向客户端通信 由于使用 script 标签的 src 属性，因此只支持 get 方法 Jsonp 和 Ajax 对比 Jsonp 和 Ajax 相同, 都是客户端向服务器端发送请求，从服务器端获取数据的方式 Ajax 属于同源策略 Jsonp 属于非同源策略 (跨域请求) Jsonp 的优缺点优点： 它不像 XMLHttpRequest 对象实现的 Ajax 请求那样受到同源策略的限制，JSONP 可以跨越同源策略 它的兼容性更好，在更加古老的浏览器中都可以运行，不需要 XMLHttpRequest 或 ActiveX 的支持 在请求完毕后可以通过调用 callback 的方式回传结果 缺点： 它只支持 GET 请求而不支持 POST 等其它类型的 HTTP 请求 它只支持跨域 HTTP 请求这种情况，不能解决不同域的两个页面之间如何进行 JavaScript 调用的问题 jsonp 在调用失败的时候不会返回各种 HTTP 状态码 缺点是安全性，万一假如提供 jsonp 的服务存在页面注入漏洞，即它返回的 javascript 的内容被人控制的 Jsonp 的实现流程 声明一个回调函数，把函数名 (show) 当做参数值 要传递给跨域请求的数据的服务器，函数形参为要获取目标数据 创建一个 script 标签，把那个跨域的 API 数据接口地址，赋值给 script 的 src，还要在这个地址中向服务器传递该函数名 服务器接收到请求后，需要进行处理：把传递的参数名和它需要的数据拼接成一个字符串 最后服务器把准备的数据通过 HTTP 协议返回给客户端，客户端再调用执行之前声明的回调函数 (show), 对返回的数据进行操作 具体代码实现如下： index.html 12345678910111213141516171819202122232425262728293031323334353637&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta &gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; function jsonp(&#123;url,params,cb&#125;)&#123; return new Promise((resolve,reject)=&gt;&#123; let script = document.createElement('script'); window[cb]=function(data)&#123; resolve(data); document.body.removeChild(script); &#125; params=&#123;...params,cb&#125; let arrs = []; for(let key in params)&#123; arrs.push(`$&#123;key&#125;=$&#123;params[key]&#125;`); &#125; script.src = `$&#123;url&#125;?$&#123;arrs.join('&amp;')&#125;`; document.body.appendChild(script) &#125;) &#125; jsonp(&#123; url:'http://localhost:3000/say', params:&#123;wd:'早上好'&#125;, cb:'show' &#125;).then(data=&gt;&#123; console.log(data) &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; serve.js 123456789let express = require('express');let app = express();app.get('/say',function (req,res)&#123; let &#123;wd,cb&#125; = req.query; console.log(wd); res.end(`$&#123;cb&#125;('晚上好')`)&#125;)app.listen(3000) 注意： 需要安装npm install express, 然后在终端里面输入node serve.js, 再把index.html在浏览器上边console栏查看返回结果 JQuery 的 jsonp 跨域请求如果从 192.168.19.1发ajax请求到 192.168.19.6 会产生跨域问题, 利用jquery的jsonp参数可轻松这个问题。 注意：Jsonp 都是 GET 和异步请求 1234567891011function get() &#123; $.ajax(&#123; type: "GET", url: 'http://192.168.19.6:8080/jsgd/bill.jsp?userCode=?&amp;date='+ new Date(), dataType:"jsonp", jsonp:"jsonpcallback", success: function(msg)&#123; $('#callcenter').html(msg.text); &#125; &#125;);&#125; cors什么是 corscors全称 “跨域资源共享”(Cross-origin resource sharing), 是一种 ajax 跨域请求资源的方式。 兼容性 cors 需要浏览器和服务器同时支持，才可以实现跨域的请求 这个方法几乎所有的浏览器都支持，但是 ie 必须是 10 以上 ie8 和 9 需要通过 XDomainRequest 来实现 请求类型cors 分为简单请求和复杂请求两类 简单请求请求方式使用下列方法之一： 123GETHEADPOST Content-Type 的值仅限于下列三者之一： 123text/plainmultipart/form-dataapplication/x-www-form-urlencoded 注意：对于简单的请求，浏览器会直接发送 cors 请求，具体来说就是在 header 中加入 origin 请求头字段。在响应头回服务器设置相关的 cors 请求, 响应头字段为允许跨域请求的源。请求时浏览器在请求头的 Origin 中说明请求的源，服务器收到后发现允许该源跨域请求，则会成功返回。 复杂请求使用了下面任一 HTTP 方法 123456PUTDELETECONNECTOPTIONSTRACEPATCH Content-Type 的值不属于下列之一： 123application/x-www-form-urlencodedmultipart/form-datatext/plain 当符合复杂请求的条件时，浏览器会自动先发送一个 options 请求。如果发现浏览器支持该请求，则会将真正的请求发送到后端。如果浏览器发现服务端不支持该请求，则会在控制台抛出错误。 cors 字段介绍 Access-Control-Allow-Methods 这个字段是必要的，它的值是逗号分割的一个字符串，表明服务器支持的所有跨域请求的方式 Access-Control-Allow-Headers 如果浏览器请求包括这个字段，则这个字段也是必须的，它也是一个逗号分隔的字符串，表明服务器支持的所有头信息字段，不限于浏览器在 “预检 “ 中请求的字段 Access-Control-Allow-Credentials 这个字段与简单请求时的含义相同 Access-Control-Max-Age 该字段可选，用来指定本次预检请求的有效期，单位为秒。上面结果中，有效期是 20 天（1728000 秒），即允许缓存该条回应 1728000 秒（即 20 天），在此期间，不用发出另一条预检请求 流程实现index.html 1234567891011&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta &gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; hello&lt;/body&gt;&lt;/html&gt; serve.js 12345let express = require('express');let app = express();app.use(express.static(__dirname));app.listen(3000) 以当前这个作为静态文件目录，先要在终端里面node serve.js服务器打开，访问localhost:3000就可以把 hello 显示出来。这是一个完整的复杂请求例子： index.js 123456789101112131415let xhr = new XMLHttpRequest()document.cookie = 'name=xiaoming'xhr.withCredentials = truexhr.open('PUT', 'http://localhost:4000/getData', true)xhr.setRequestHeader('name', 'xiaoming')xhr.onreadystatechange = function() &#123;if (xhr.readyState === 4) &#123; if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status === 304) &#123; console.log(xhr.response) //得到响应头，后台需设置Access-Control-Expose-Headers console.log(xhr.getResponseHeader('name')) &#125;&#125;&#125;xhr.send() serve.js 12345let express = require('express');let app = express();app.use(express.static(__dirname));app.listen(3000) serve2.js 1234567891011121314151617181920212223242526272829303132333435let express = require('express')let app = express()let whitList = ['http://localhost:3000']app.use(function(req, res, next) &#123; let origin = req.headers.origin if (whitList.includes(origin)) &#123; res.setHeader('Access-Control-Allow-Origin', origin) res.setHeader('Access-Control-Allow-Headers', 'name') res.setHeader('Access-Control-Allow-Methods', 'PUT') res.setHeader('Access-Control-Allow-Credentials', true) res.setHeader('Access-Control-Max-Age', 6) res.setHeader('Access-Control-Expose-Headers', 'name') if (req.method === 'OPTIONS') &#123; res.end() &#125; &#125; next()&#125;)app.put('/getData', function(req, res) &#123; console.log(req.headers) res.setHeader('name', 'ming') res.end('早上好')&#125;)app.get('/getData', function(req, res) &#123; console.log(req.headers) res.end('早上好')&#125;)app.use(express.static(__dirname))app.listen(4000) Cors 与 Jsonp 比较 cors 比 Jsonp 更强大 Jsonp 只支持 Get 请求，cors 支持所有类型的 HTTP 请求 使用 cors，可以使用 XMLHttpRequest 发起请求和获取数据，比 Jsonp 有更好的错误处理 Jsonp 的优势在于支持老式浏览器和可以向 cors 的网络请求数据 cors 与 Jsonp 相比，更方便可靠 postMessage什么是 postMessagepostMessage方法允许来自不同源的脚本采用异步方式进行有限的通信，可以实现跨文本档、多窗口、跨域消息传递。 postMessage 语法1otherWindow.postMessage(message, targetOrigin, [transfer]) otherWindow：其它窗口 (目标窗口) 的引用，比如 iframe 的 contentWindow 属性、执行 window.open 返回的窗口对象、或者是命名过或数值索引的 window.frames message：将要发送到其他 window 的数据，这个数据会自动被序列化，数据格式也不受限制 (字符串，对象都可以) targetOrigin：目标窗口的源，可以是字符串 * 表示无限制，或 URL, 需要协议端口号和主机都匹配才会发送 transfer(可选)：是一串和 message 同时传递的 Tranferable 对象，这些对象的所有权将 被转移给消息接收方，而发送一方将不再保有所有权 兼容性高级浏览器Internet Explorer 8+, chrome，Firefox , Opera 和 Safari 都将支持这个功能 流程实现 a.html 向 b.html 传递 “早上好”，然后 a.html 传回 “今天天气真好” a.html 12345678910&lt;iframe src="http://localhost:4000/b.html" frameborder="0" id="frame" onload="load()"&gt;&lt;/iframe&gt;&lt;script&gt;function load()&#123; let frame = document.getElementById('frame'); frame.contentWindow.postMessage('早上好','http://localhost:4000'); window.onmessage=function(e)&#123; console.log(e.data) &#125;&#125;&lt;/script&gt; b.html 123456&lt;script&gt; window.onmessage = function(e)&#123; console.log(e.data); e.source.postMessage('今天天气不错',e.origin) &#125;&lt;/script&gt; a.js 1234let express = require('express')let app = express();app.use(express.static(__dirname));app.listen(3000) b.js 1234let express = require('express')let app = express();app.use(express.static(__dirname));app.listen(4000) Window.name什么是 Window.namewindow.name 是一个 window 对象的内置属性，name 属性可以设置或返回存放窗口的名称的一个字符串。 该属性的特征在页面在浏览器端展示的时候，我们总能在控制台拿到一个全局变量 window，该变量有一个 name 属性，有以下的特征： 每个窗口都有独立的 window.name 与之对应 在一个窗口的生命周期中 (被关闭前)，窗口载入的所有页面同时共享一个 window.name，每个页面 window.name 都有读写的权限 window.name 一直存在与当前窗口，即使是新的页面载入也不会改变 window.name 的值 window.name 可以存储不超过 2M 的数据，数据个数按需自定义 流程实现 a.html 和 b.html 是同域 http://localhost:3000 c.html 是独立的 http://localhost:4000 a 获取 c 的数据 a 先引用 c c 把值放到window.name, 把 a 引用的地址改为 b a.html 12345678910111213&lt;iframe src="http://localhost:4000/c.html" frameborder="0" onload="load()" id="iframe"&gt;&lt;/iframe&gt;&lt;script&gt; let first = true function load()&#123; if(first)&#123; let iframe = document.getElementById('iframe'); iframe.src="http://localhost:3000/b.html"; first = false; &#125;else&#123; console.log(iframe.contentWindow.name) &#125; &#125;&lt;script&gt; b.html 123&lt;body&gt; 早上好&lt;/body&gt; c.html 123&lt;script&gt; window.name='今天天气不错'&lt;/script&gt; a.js 1234let express = require('express')let app = express();app.use(express.static(__dirname));app.listen(3000) b.js 1234let express = require('express')let app = express();app.use(express.static(__dirname));app.listen(4000) location.hash什么是 location.hashlocation是javascript里面的内置对象，如location.href就管理页面的 url，用loaction.href=url就可以直接将页面重定向 url, 而location.hash则可以用来获取或设置页面的标签值，hash 属性是一个可读可写的字符串，该字符串是 URL 的锚部分 (从 #号开始的部分) location.hash 的简单应用#的含义 #代表网页中的位置，其右边的字符，就是该位置的标识符，例如： 1http: 就是代表 index.html 的 drafts 位置，浏览器读取这个 URL 后，会自动将 print 位置滚动至可视区域 HTTP 请求不包括# #是用来指导浏览器的动作的，对服务器端完全无用，所以，HTTP 请求中不包括#例如： 1http: 浏览器实际发出的请求是这样的： 12GET/index.html HTTP/1.1Host:www.juejin.com 可以看到，只是请求的 index.html, 没有 #drafts 部分 #后的字符 在第一个 #出现的任何字符，都会被浏览器解读为位置标识符，这意味着，这些字符不会被发送到服务器端 改变 #不触发网页重构 单单改变 #后的部分，浏览器只会滚动到相应的位置，不会重新加载网页 改变 #会改变浏览器的访问历史 每一次改变 #后的部分，都会在浏览器的访问历史中增加一个记录，使用 “后退” 按钮，就可以回到上一个位置 读取 #值 window.location.hash 这个属性可读可写。读取时，可以用来判断网页状态是否改变；写入时，则会在不重载网页的前提下，创造一条访问历史记录 onhashchange 事件 当 #值发生变化时，就会触发这个事件。IE8+、Firefox 3.6+、Chrome 5+、Safari 4.0 + 支持该事件 Google 抓取 #的机制 默认情况下，Google 的网络忽视 URL 的 #部分 流程实现路径后面的 hash 值可以用来通信。目的：a.html 想访问 c.html跨域相互通信。 a.html 给 c.html 传一个 hash 值, 需要通过中间的 b.html 来实现 c.html 收到 hash 值后 c.html 把 hash 值传递给 b.html b.html 将结果放到 a.html 的 hash 值中 a.html 123456&lt;iframe src="http://localhost:4000/c.html#goodmorning"&gt;&lt;/iframe&gt;&lt;script&gt; window.onhashchange = function () &#123; console.log(location.hash); &#125;&lt;/script&gt; b.html 123&lt;script&gt; window.parent.parent.location.hash = location.hash &lt;/script&gt; c.html 123456&lt;script&gt; console.log(location.hash); let iframe = document.createElement('iframe'); iframe.src = 'http://localhost:3000/b.html#goodevening'; document.body.appendChild(iframe);&lt;/script&gt; a.js 1234let express = require('express')let app = express();app.use(express.static(__dirname));app.listen(3000) b.js 1234let express = require('express')let app = express();app.use(express.static(__dirname));app.listen(4000) domain什么是 domain主要用于主域相同的域之间的数据通信，注意 仅限主域相同，子域不同的跨域应用场景。 实现的原理：两个页面都通过 js 强制设置 document.domain 为基础主域，就实现了同域 说明这个方法只能用于二级域名相同的情况下, 比如： 12www.baidu.comhhh.baidu.com 这就适用于 domain 方法 流程实现a.html 1234567&lt;iframe src="http://b.ming.cn:3000/b.html" frameborder="0" onload="load()" id="frame"&gt;&lt;/iframe&gt;&lt;script&gt; document.domain = 'ming.cn' function load() &#123; console.log(frame.contentWindow.a); &#125;&lt;/script&gt; b.html 1234567&lt;div&gt; 早上好啊&lt;/div&gt;&lt;script type="text/javascript"&gt; document.domain = 'ming.cn' var a = 99999;&lt;/script&gt; a.js 123456let express = require('express')let app = express();app.use(express.static(__dirname));app.listen(3000, () =&gt; &#123; console.log('server run at 3000')&#125;) b.js 123456let express = require('express')let app = express();app.use(express.static(__dirname));app.listen(4000, () =&gt; &#123; console.log('server run at 4000')&#125;) 这个就可以通过 http://a.ming.cn:3000/a.html 获取到页面 http://a.ming.cn:3000/b.htm 中的 a 的值 99999 注意：这里我把我电脑上边的 hosts 修改了一下，不然不能出来效果 WebSocket什么是 WebSocketWebSocket是一种网络通信协议，它实现了浏览器与服务器全双工通信，同时允许跨域通讯。原生 WebSocket API 使用起来不太方便，我们使用Socket.io，它很好地封装了 webSocket 接口，提供了更简单、灵活的接口，也对不支持 webSocket 的浏览器提供了向下兼容。 WebSocket 如何工作Web 浏览器和服务器都必须实现 WebSockets 协议来建立和维护连接。由于 WebSockets 连接长期存在，与典型的 HTTP 连接不同，对服务器有重要的影响。 注意：基于多线程或多进程的服务器无法适用于WebSockets，因为它旨在打开连接，尽可能快地处理请求，然后关闭连接。任何实际的WebSockets服务器端实现都需要一个异步服务器。 流程实现a.html 12345678910&lt;script&gt; let socket = new WebSocket('ws://localhost:3000'); socket.onopen=function()&#123; socket.send('早上好啊') &#125; socket.onmessage = function(e)&#123; console.log(e.data); &#125;&lt;/script&gt; a.js 12345678910let express = require('express')let app = express();let WebSocket = require('ws')let wss = new WebSocket.Server(&#123;port:3000&#125;)wss.on('connection',function(ws)&#123; ws.on('message',function(data)&#123; console.log(data) ws.send('今天天气真好') &#125;)&#125;) 总结以上就是整理的一些跨域的方法，我觉得一般用 cors,jsonp 等常见的方法就可以了，不过遇到了一些特殊情况，我们也要做到有很多方法是可以选择的，相信这篇文字会对大家有帮助!]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019Nian终总结]]></title>
    <url>%2Farchives%2F1e218812.html</url>
    <content type="text"><![CDATA[在某些时候，需要将自己以往的经历归零，因为有些东西是放在一定条件下它才成立，不要总是说过去怎样怎样，你拥有的资源、所处的环境不同，那么结果就是不一样 2019 Nian琐事 北京——杭州——武汉 结束了异地恋 养了一只猫 终于有了自己的Mac 去宜昌旅游了一次 发现了一个笔记神器Notion (记录了36篇文章) 用Hexo搭建了自己的博客 (更新了17篇文章) 将博客进行了SEO 技术栈 HTML5 CSS3 JavaScript ES5/ES6 Vue Node Nginx Less/Sass JQuery 小程序 博客搭建 域名代理 HTTP 2020 Nian规划 要明确的知道自己想要的是什么 不要对自己设限 博客坚持持续更新 GitHub贡献开源 进大厂 技术向上 技术栈 TypeScript React React-Native Angular Webpack Serverless Fultter 📍北京 📍杭州日月同辉广场 📍武汉长江大桥 🐱我的猫叫奶粉AND人生中第一台Mac 🏡武汉的家 💑哈哈哈]]></content>
  </entry>
  <entry>
    <title><![CDATA[Vue程序化的事件监听器]]></title>
    <url>%2Farchives%2Fa85e4219.html</url>
    <content type="text"><![CDATA[某些第三方插件必须在当前组件卸载后清除该实例（比如说百度的富文本框UEditor 如果不清除再次在下个组件使用时会有bug， 类似于小程序的语音实例，必须离开页面的时候销毁当前语音实例，不然语音会一直播放） 方案1： 12345data() &#123; return &#123; timer: null // 定时器名称 &#125; &#125;, 然后这样使用定时器： 123this.timer = setIterval (() =&gt; &#123; // 某些操作&#125;, 1000) 最后在beforeDestroy()生命周期内清除定时器： 1234beforeDestroy() &#123; clearInterval(this.timer); this.timer = null;&#125; 次方案有两点不好的地方，引用尤大的话来说就是： (1)它需要在这个组件实例中保存这个数据timer，这是多余的。(2)我们的建立定时器代码独立于我们的清理代码（定时器需要卸载页面的时候卸载），这使得我们比较难于程序化的清理我们建立的所有东西（意思是执行代码和清除代码不在一起）。方案2： 该方法是通过$once这个事件侦听器器在定义完定时器之后的位置来清除定时器。以下是完整代码： 123456789mounted: function () &#123; const timer = setInterval(() =&gt;&#123; // 某些定时器操作 &#125;, 500); // 通过$once来监听定时器，在beforeDestroy钩子可以被清除。 this.$once('hook:beforeDestroy', () =&gt; &#123; clearInterval(timer); &#125;)&#125; 简单来说就是把所有创建实例和需要销毁的实例代码放在一起了，放在一起而已(创建实例和销毁实例)……..甚至可以在一个页面开启多个这种创建实例和销毁实例12345678910111213141516mounted: function () &#123; this.attachDatepicker('startDateInput') this.attachDatepicker('endDateInput')&#125;,methods: &#123; attachDatepicker: function (refName) &#123; var picker = new Pikaday(&#123; field: this.$refs[refName], format: 'YYYY-MM-DD' &#125;) this.$once('hook:beforeDestroy', function () &#123; picker.destroy() &#125;) &#125;&#125; 综合来说，我们更推荐使用方案2，使得代码可读性更强，一目了然。如果不清楚$once、$on、$off的使用，这里送上官网的地址教程，在程序化的事件侦听器那里。]]></content>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue inheritAttrs, $attrs,$listeners 详解]]></title>
    <url>%2Farchives%2Fd95d5814.html</url>
    <content type="text"><![CDATA[1、vm.$attrs简介首先我们来看下vue官方对vm.$attrs的介绍： 包含了父作用域中不作为 prop 被识别 (且获取) 的特性绑定 (class 和 style 除外)。当一个组件没有声明任何 prop 时，这里会包含所有父作用域的绑定 (class 和 style 除外)，并且可以通过 v-bind=”$attrs” 传入内部组件——在创建更高层次的组件时非常有用。 猛一看有点看不明白…. 2、场景介绍vue中一个比较令人烦恼的事情是属性只能从父组件传递给子组件。这也就意味着当你想向嵌套层级比较深组件数据传递，只能由父组件传递给子组件，子组件再传递给孙子组件…像下面这样： 1234567&lt;parent-component :passdown="passdown"&gt;&lt;child-component :passdown="passdown"&gt;&lt;grand-child-component :passdown="passdown"&gt;.... 就这样一层一层的往下传递passdown这个变量，最后才能用{{passdown}}。假如我们需要传递的属性只有1,2个还行，但是如果我们要传递的有几个或者10来个的情况，这会是什么样的场景，我们会在每个组件不停的props，每个必须写很多遍。有没有其它方便的写法？有，通过vuex的父子组件通信，的确这个是一个方法，但是还有其它的方法，这个就是我们要说的。通过inheritAttrs选项，以及实例属性$attrs 3、实例：123456789101112131415161718192021222324252627282930&lt;template&gt; &lt;div class="home"&gt; &lt;mytest :title="title" :massgae="massgae"&gt;&lt;/mytest&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: 'home', data () &#123; return &#123; title:'title1111', massgae:'message111' &#125; &#125;, components:&#123; 'mytest':&#123; template:`&lt;div&gt;这是个h1标题&#123;&#123;title&#125;&#125;&lt;/div&gt;`, props:['title'], data()&#123; return&#123; mag:'111' &#125; &#125;, created:function()&#123; console.log(this.$attrs)//注意这里 &#125; &#125; &#125;&#125;&lt;/script&gt; 上边的代码，我们在组件里只是用了title这个属性，massgae属性我么是没有用的，那么下浏览器渲染出来是什么样呢？如下图： 我们看到：组件内未被注册的属性将作为普通html元素属性被渲染，如果想让属性能够向下传递，即使prop组件没有被使用，你也需要在组件上注册。这样做会使组件预期功能变得模糊不清，同时也难以维护组件的DRY。在Vue2.4.0,可以在组件定义中添加inheritAttrs：false，组件将不会把未被注册的props呈现为普通的HTML属性。但是在组件里我们可以通过其$attrs可以获取到没有使用的注册属性，如果需要，我们在这也可以往下继续传递。 如果我们在子组件里设置 inheritAttrs: false： 1234567891011121314components:&#123; 'mytest':&#123; template:`&lt;div&gt;这是个h1标题&#123;&#123;title&#125;&#125;&lt;/div&gt;`, props:['title'], inheritAttrs: false, data()&#123; return&#123; mag:'111' &#125; &#125;, created:function()&#123; console.log(this.$attrs)//注意这里 &#125; &#125; 渲染效果如下： 补充：说一下$attrs的使用有一个页面由父组件，子组件，孙子组件构成，如下： 1234567891011121314151617181920212223242526272829303132&lt;template&gt; &lt;div style="padding:50px;"&gt; &lt;childcom :name="name" :age="age" :sex="sex"&gt;&lt;/childcom&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; 'name':'test', props:[], data()&#123; return &#123; 'name':'张三', 'age':'30', 'sex':'男' &#125; &#125;, components:&#123; 'childcom':&#123; template:`&lt;div&gt; &lt;div&gt;&#123;&#123;name&#125;&#125;&lt;/div&gt; &lt;grandcom v-bind="$attrs"&gt;&lt;/grandcom&gt; &lt;/div&gt;`, props:['name'], components: &#123; 'grandcom':&#123; template:`&lt;div&gt;&#123;&#123;$attrs&#125;&#125;&lt;/div&gt;`, &#125; &#125; &#125; &#125;&#125;&lt;/script&gt; 上面的代码在页面的效果是如下图 如果attrs被绑定在子组件childcom上后，我们就可以在孙子组件grandcom里获取到this.$attrs的值。这个的值是父组件中传递下来的props（除了子组件childcom组件中props声明的）。 记住孙子组件grandcom里获取到this.$attrs的值是除了子组件childcom声明的元素！记住是除了子组件childcom声明的元素！例如上面的代码我在子组件childcom组件的props里声明了name，那么我在孙子组件grandcom里获取到的$attrs就不包含name属性，那么this.$attrs = { ‘age’:’30’, ‘sex’:’男’}。 补充：说一下$attrs的优势到底在哪假如我们要做一个页面，有父组件，子组件，孙子组件，如下： 12345678910111213141516171819202122232425262728293031&lt;template&gt; &lt;div&gt; &lt;childcom&gt;&lt;/childcom&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; 'name':'test', props:[], data()&#123; return &#123; 'name':'张三', 'age':'30', 'sex':'男' &#125; &#125;, components:&#123; 'childcom':&#123; template:`&lt;div&gt; &lt;div&gt;我是子组件&lt;/div&gt; &lt;grandcom&gt;&lt;/grandcom&gt; &lt;/div&gt;`, components: &#123; 'grandcom':&#123; template:`&lt;div&gt;我是孙子组件&lt;/div&gt;`, &#125; &#125; &#125; &#125;&#125;&lt;/script&gt; 如上代码，假如我想在子组件想获取到父组件的name属性值，在孙子组件获取父组件的age属性值，用props的话就必须在父组件把name和age的值通过props传递到子组件，子组件在通过props把age的值传递到孙子组件，到这里看明白了吧，孙子组件需要的age在子组件里没有用到，但是为了能让孙子组件获取到，你必须从父组件 传到子组件，在在子组件传递到孙子组件。 但是用$attrs就不用那么麻烦，如下： 1234567891011121314151617181920212223242526272829303132&lt;template&gt; &lt;div&gt; &lt;childcom :name="name" :age="age" :sex="sex"&gt;&lt;/childcom&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; 'name':'test', props:[], data()&#123; return &#123; 'name':'张三', 'age':'30', 'sex':'男' &#125; &#125;, components:&#123; 'childcom':&#123; props:['name'], template:`&lt;div&gt; &lt;div&gt;我是子组件 &#123;&#123;name&#125;&#125;&lt;/div&gt; &lt;grandcom v-bind="$attrs"&gt;&lt;/grandcom&gt; &lt;/div&gt;`, components: &#123; 'grandcom':&#123; template:`&lt;div&gt;我是孙子组件&#123;&#123;$attrs.age&#125;&#125;&lt;/div&gt;`, &#125; &#125; &#125; &#125;&#125;&lt;/script&gt; 子组件绑定了”$attrs”，孙子组件就能获取到除了name属性外所有由父组件传递下来的属性。如果孙子组件也想获取到name属性那么，在绑定个name如下， 1&lt;grandcom v-bind="$attrs" :name="name"&gt;&lt;/grandcom&gt; 细细体会下是不是这个道理。实在不行的话敲一敲代码自己试验下，你就会豁然开朗。 inheritAttrs属性关于inheritAttrs这个属性跟获取到$attrs的值没有关系，inheritAttrs通常在编写基础组件时候会用到。官网原话：默认情况下父作用域的不被认作 props 的特性绑定 (attribute bindings) 将会“回退”且作为普通的 HTML 特性应用在子组件的根元素上。当撰写包裹一个目标元素或另一个组件的组件时，这可能不会总是符合预期行为。通过设置 inheritAttrs 到 false，这些默认行为将会被去掉。而通过 (同样是 2.4 新增的) 实例属性 $attrs 可以让这些特性生效，且可以通过 v-bind 显性的绑定到非根元素上。 注意：这个选项不影响 class 和 style 绑定。 在Vue2.4.0之前版本，组件内未被注册的属性将作为普通html元素属性被渲染。 inheritAttrs到底有啥用？到底用在哪里？看下边代码， 12345678910111213141516171819202122&lt;template&gt; &lt;childcom :name="name" :age="age" type="text"&gt;&lt;/childcom&gt;&lt;/template&gt;&lt;script&gt;export default &#123; 'name':'test', props:[], data()&#123; return &#123; 'name':'张三', 'age':'30', 'sex':'男' &#125; &#125;, components:&#123; 'childcom':&#123; props:['name','age'], template:`&lt;input type="number" style="border:1px solid blue"&gt;`, &#125; &#125;&#125;&lt;/script&gt; 上面代码你觉得input上会怎么显示？ 父组件传递了type=”text”，子组件里input 上type=”number”，那渲染到页面会是什么样？渲染图如下： 看到没，父组件传递的type=”text”覆盖了input 上type=”number”，这岂不是把我的input数据类型都给改变了，这岂不是有问题，这不是我想要的！！！！看到这里明白了吗？回头去体会下上面官网的原话！！！ 需求：我需要input 上type=”number”类型不变，但是我还是要取到父组件的type=”text”的值，那么代码如下： 1234567891011121314151617181920212223242526&lt;template&gt; &lt;childcom :name="name" :age="age" type="text"&gt;&lt;/childcom&gt;&lt;/template&gt;&lt;script&gt;export default &#123; 'name':'test', props:[], data()&#123; return &#123; 'name':'张三', 'age':'30', 'sex':'男' &#125; &#125;, components:&#123; 'childcom':&#123; inheritAttrs:false, props:['name','age'], template:`&lt;input type="number" style="border:1px solid blue"&gt;`, created () &#123; console.log(this.$attrs.type) &#125; &#125; &#125;&#125;&lt;/script&gt; 页面渲染图如下： 到这，我想大家都明白了inheritAttrs的作用了吧。默认情况下vue会把父作用域的不被认作 props 的特性绑定 且作为普通的 HTML 特性应用在子组件的根元素上。绑定就绑定，显示就显示，没啥大不了的，但是怕就怕遇到一些特殊的，就比如上面的input的情况，这个时候inheritAttrs:false的作用就出来啦。 $listeners父组件-子组件-孙子组件，，，，现在我要你在孙子组件里改变父组件的值，怎么改？有很多方法啦，但是$listeners给我们提供了一个新的思路。话不多说，直接上代码 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;template&gt; &lt;div&gt; &lt;childcom :name="name" :age="age" :sex="sex" @testChangeName="changeName"&gt;&lt;/childcom&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; 'name':'test', props:[], data()&#123; return &#123; 'name':'张三', 'age':'30', 'sex':'男' &#125; &#125;, components:&#123; 'childcom':&#123; props:['name'], template:`&lt;div&gt; &lt;div&gt;我是子组件 &#123;&#123;name&#125;&#125;&lt;/div&gt; &lt;grandcom **v-bind="$attrs" v-on="$listeners"**&gt;&lt;/grandcom&gt; &lt;/div&gt;`, components: &#123; 'grandcom':&#123; template:`&lt;div&gt;我是孙子组件-------&lt;button @click="grandChangeName"&gt;改变名字&lt;/button&gt;&lt;/div&gt;`, methods:&#123; grandChangeName()&#123; this.$emit('testChangeName','kkkkkk') &#125; &#125; &#125; &#125; &#125; &#125;, methods:&#123; changeName(val)&#123; this.name = val &#125; &#125;&#125;&lt;/script&gt; 页面渲染如下 $listeners可以让你在孙子组件触发变yeye组件的事件，是不是很方便]]></content>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue的组件通信之Provide与Inject机制]]></title>
    <url>%2Farchives%2Ff29baeb3.html</url>
    <content type="text"><![CDATA[Vue中父组件到子组件的通信主要由子组件的props属性实现。但是在一些情况下，父组件无法直接向子组件的props传值。比如子组件通过父组件的slot进入父组件，父组件根本不知道子组件是谁，更不用说用子组件的props了。这时应该怎么办呢？Vue在2.2.0版本引入了provide与inject，正好适合处理这一情况。 什么是provide与inject用文档的话说： provide/inject需要一起使用，以允许一个祖先组件向其所有子孙后代注入一个依赖，不论组件层次有多深，并在起上下游关系成立的时间里始终生效。如果你熟悉 React，这与 React 的上下文特性很相似。 这就是说从父组件的provide属性传入一个对象，子组件（或者是孙组件，只要是子级组件）可以用inject属性接收父组件的provide属性。比如 12345678910111213141516171819202122232425262728293031323334353637// main.vue&lt;template&gt; &lt;c1 message="hello world"&gt; &lt;c2&gt;&lt;/c2&gt; &lt;/c1&gt;&lt;/template&gt; // c1.vue&lt;template&gt; &lt;div id="c1"&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/div&gt;&lt;/template&gt; &lt;script&gt;export default &#123; props: ['message'], provide () &#123; return &#123; message: this.message &#125; &#125;&#125;&lt;/script&gt; // c2.vue&lt;template&gt; &lt;div id="c2"&gt; &#123;&#123; message &#125;&#125; &lt;/div&gt;&lt;/template&gt; &lt;script&gt;export default &#123; inject: ['message']&#125;&lt;/script&gt; 上面的main组件会被渲染为: 123&lt;div id="c1"&gt; &lt;div id= "c2"&gt;hello world&lt;/div&gt;&lt;/div&gt; 可以看到，c1组件在不清楚子组件是什么的情况下，将它的props中的message传给了c2组件。在这里c1组件就像是一个数据源一样，为子组件提供数据。但是，c1组件提供的数据仅在c1的子孙组件中可见，因此可以算作是有作用域限定的数据源。 父到子孙组件方向的数据流父到子孙组件方向是provide/inject机制设计时的数据流方向。我们可能会猜想，在父组件中更改provide的值，子组件会响应式的发生改变。但是注意到文档中话。 提示：provide和inject绑定并不是可响应的。这是刻意为之的。然而，如果你传入了一个可监听的对象，那么其对象的属性还是可响应的。 这意味着，如果provide的值不是可监听对象时，在父组件中更改provide的值，子组件不会发生任何变化。比如模板仍然为上面那个例子的模板，message的值是一个props属性，不是可监听对象，如果我们在c1的mounted钩子函数里改变message的值。如: 1234567891011// c1.vue&lt;script&gt;export default &#123; //... mounted () &#123; setTimeout( () =&gt; &#123; this.message = 'Opps, it would not be rendered' &#125;, 1000) &#125;&#125;&lt;/script&gt; 子组件不会响应修改后的值。 但是如果provide的值是一个可监听对象呢？请看一下例子： 12345678910111213141516171819202122232425262728293031&lt;script&gt;// c1.vueexport default &#123; data () &#123; return &#123; message: 'hello world' &#125; &#125;, provide () &#123; messageData: this.$data &#125;, mounted () &#123; setTimeout(() =&gt; &#123; this.message = 'I can show in c2.' &#125;, 10000) &#125;&#125;&lt;/script&gt; // c2.vue&lt;template&gt; &lt;div id="c2"&gt; &#123;&#123; messageData.message &#125;&#125; &lt;/div&gt;&lt;/template&gt; &lt;script&gt;export default &#123; inject: ['messageData']&#125;&lt;/script&gt; 此时在c1挂载10s后，子组件将会显示I can show in c2。为什么呢？c2中messageData实际上就是c1实例的this.$data。而this.$data上有message的响应式getter与setter。所以c2的视图会被message的dep收集，因此在c1中更新message，c2的视图也会更新。 纵观整个过程，provide/inject机制是非响应式的，即provide与inject之间没有绑定。具体的值是在子组件初始化过程中决定的。 总结provide/inject提供了一种新的组件间通信的方法。它允许父组件向子孙组件间进行跨层级的数据分发。但是provide/inject是非响应式的，如果要子孙组件根据父组件的值进行改变，provide/inject机制不是一个好的选择。此时可以使用Vuex来管理状态。]]></content>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[再读一次Vue官方文档带来的意外惊喜]]></title>
    <url>%2Farchives%2F3a867b5d.html</url>
    <content type="text"><![CDATA[前言 Vue目前算是我用的时间最长的一个框架了,但是最近总是在想,我真的了解Vue了吗,还是说,仅仅只是会用它而已了呢.最开始用Vue的时候只是草草看了一遍文档,细节之处并未关心,以至于后面项目中遇到很多问题之后才又反复的去查文档,解决问题.我认为,不应该是这样的,这种程度,仅仅只能让我有处理问题的能力,虽然经验让我再遇到问题的时候知道大概的导向,但这样永远不会建立起对Vue技术怀有的自信.于是,我打算再来一遍官方文档,记录其中从未曾了解过的东西.在这之后,我便会去尝试着去读读Vue的源码,并分享出来. 动态参数&lt;a :[attributeName]=&quot;url&quot;&gt; ... &lt;/a&gt; 这里的 attributeName 会被作为一个 JavaScript 表达式进行动态求值，求得的值将会作为最终的参数来使用。例如，如果你的 Vue 实例有一个 data 属性 attributeName，其值为 “href”，那么这个绑定将等价于 v-bind:href 注意点: attributeName 应该全部都是小写 attributeName 如果是通过表达式生成的,那应将其放在计算属性中,避免直接在HTML中书写表达式 动态class和style的几种写法 class 1234567891011121314151. &lt;div v-bind:class="&#123; 'active': isActive, 'text-danger': hasError &#125;"&gt;&lt;/div&gt; // 对象语法2. &lt;div v-bind:class="classObject"&gt;&lt;/div&gt;// 对象语法3. &lt;div v-bind:class="[&#123; 'active': isActive &#125;, errorClass]"&gt;&lt;/div&gt;// 数组语法 data: &#123; isActive: true, hasError: false, classObject: &#123; active: true, 'text-danger': false &#125;, errorClass: 'text-danger' &#125; style 1234567891011121314151617181. &lt;div v-bind:style="&#123; color: activeColor, fontSize: fontSize + 'px' &#125;"&gt;&lt;/div&gt;// 对象语法2. &lt;div v-bind:style="styleObject"&gt;&lt;/div&gt;// 对象语法3. &lt;div v-bind:style="[styleObject, styleObject2]"&gt;&lt;/div&gt;// 数组语法data: &#123; activeColor: 'red', fontSize: 30, styleObject: &#123; color: 'red', fontSize: '13px' &#125;, styleObject2: &#123; color: 'blac', fontSize: '13px' &#125;&#125; v-showv-show 不支持 &lt;template&gt; 元素，也不支持 v-else v-forv-for遍历对象 123&lt;div v-for="(value, name, index) in object"&gt; &#123;&#123; index &#125;&#125;. &#123;&#123; name &#125;&#125;: &#123;&#123; value &#125;&#125;&lt;/div&gt; Vue无法检测的数据变动的情况 数组 当你利用索引直接设置一个数组项时，例如：vm.items[indexOfItem] = newValue 当你修改数组的长度时，例如：vm.items.length = newLength 解决办法: 使用vm.$set() eg. vm.$set(vm.items, indexOfItem, newValue) 为数组重新赋值新修改的数组 对象 对象属性的添加 对象属性的删除 解决办法: 为对象初始一个空的将要添加的对象 使用vm.$set() eg. vm.$set(vm.Obj, keyOfObj, newValue) 使用Object.assign() eg. vm.userProfile = Object.assign({}, vm.userProfile, { age: 27, favoriteColor: &#39;Green&#39;}) 事件修饰符 .stop 阻止事件冒泡 .prevent 阻止浏览器默认行为发生 .capture 捕获冒泡，即有冒泡发生时，有该修饰符的dom元素会先执行，如果有多个，从外到内依次执行，然后再按自然顺序执行触发的事件 .self 将事件绑定到自身，只有自身才能触发，通常用于避免冒泡事件的影响 .once 设置事件只能触发一次，比如按钮的点击等 .passive 执行浏览器的默认行为 【浏览器只有等内核线程执行到事件监听器对应的JavaScript代码时，才能知道内部是否会调用preventDefault函数来阻止事件的默认行为，所以浏览器本身是没有办法对这种场景进行优化的。这种场景下，用户的手势事件无法快速产生，会导致页面无法快速执行滑动逻辑，从而让用户感觉到页面卡顿。】通俗点说就是每次事件产生，浏览器都会去查询一下是否有preventDefault阻止该次事件的默认动作。我们加上passive就是为了告诉浏览器，不用查询了，我们没用preventDefault阻止默认动作。这里一般用在滚动监听，@scoll，@touchmove 。因为滚动监听过程中，移动每个像素都会产生一次事件，每次都使用内核线程查询prevent会使滑动卡顿。我们通过passive将内核线程查询跳过，可以大大提升滑动的流畅度 键盘按键修饰符 .enter .tab .delete .esc .space .up .down .left .right 鼠标按钮修饰符 .left .right .middle 系统修饰键可以用如下修饰符来实现仅在按下相应按键时才触发鼠标或键盘事件的监听器。 .ctrl .alt .shift .meta 对应command 键 (⌘)和Windows 徽标键 (⊞) .exact 12345678&lt;!-- 即使 Alt 或 Shift 被一同按下时也会触发 --&gt;&lt;button @click.ctrl="onClick"&gt;A&lt;/button&gt;&lt;!-- 有且只有 Ctrl 被按下的时候才触发 --&gt;&lt;button @click.ctrl.exact="onCtrlClick"&gt;A&lt;/button&gt;&lt;!-- 没有任何系统修饰符被按下的时候才触发 --&gt;&lt;button @click.exact="onClick"&gt;A&lt;/button&gt; v-model修饰符 .lazy 在“change”时而非“input”时更新 .number 自动将输入值转为number类型 .trim 自动过滤用户输入的首尾空白字符 Vue全局导入基础组件的示例代码详述👉🏻chrisvfritz/vue-enterprise-boilerplate 12345678910import ElTableColumnPro from './ElTableColumnPro.vue'ElTableColumnPro.install = function (Vue) &#123; Vue.component(ElTableColumnPro.name, ElTableColumnPro)&#125;if (window.Vue) &#123; window.Vue.use(ElTableColumnPro)&#125;export default ElTableColumnPro 插槽123456789101112131415161718192021222324252627&lt;!-- 插槽模板 --&gt;&lt;div class="container"&gt; &lt;header&gt; &lt;slot name="header"&gt;&lt;/slot&gt; &lt;/header&gt; &lt;main&gt; &lt;slot&gt;&lt;/slot&gt; &lt;/main&gt; &lt;footer&gt; &lt;slot name="footer"&gt;&lt;/slot&gt; &lt;/footer&gt;&lt;/div&gt;&lt;!-- 使用 --&gt;&lt;base-layout&gt; &lt;template v-slot:header&gt; &lt;h1&gt;Here might be a page title&lt;/h1&gt; &lt;/template&gt; &lt;template v-slot:default&gt; &lt;p&gt;A paragraph for the main content.&lt;/p&gt; &lt;p&gt;And another one.&lt;/p&gt; &lt;/template&gt; &lt;template v-slot:footer&gt; &lt;p&gt;Here's some contact info&lt;/p&gt; &lt;/template&gt;&lt;/base-layout&gt; inheritAttrs , $attrs , $listeners总结一句话: $attrs存储非prop特性，inheritAttrs控制vue对非prop特性默认行为 详述👉🏻Vue inheritAttrs, $attrs,$listeners 详解 依赖注入 provide 和 inject12345678// 父组件provide: function () &#123; return &#123; getMap: this.getMap &#125;&#125;// 父组件下的所有组件(子,孙,重孙...)inject: ['getMap'] 详述👉🏻Vue的组件通信之Provide与Inject机制 程序化的事件侦听器（懵逼的定义–其实就是创建实例和清除实例放在一起,简化操作和无用的代码） 通过 $on(eventName, eventHandler) 侦听一个事件 通过 $once(eventName, eventHandler) 一次性侦听一个事件 通过 $off(eventName, eventHandler) 停止侦听一个事件 详述👉🏻vue 程序化的事件侦听器 强制更新 $forceUpdate如果你发现你自己需要在 Vue 中做一次强制更新，99.9% 的情况，是你在某个地方做错了事。 你可能还没有留意到数组和对象的变更检测注意事项，或者你可能依赖了一个未被 Vue 的响应式系统追踪的状态。 然而，如果你已经做到了上述的事项仍然发现在极少数的情况下需要手动强制更新，那么你可以通过 $forceUpdate 来做这件事。 通过 v-once 创建低开销的静态组件渲染普通的 HTML 元素在 Vue 中是非常快速的，但有的时候你可能有一个组件，这个组件包含了大量静态内容。在这种情况下，你可以在根元素上添加 v-once 特性以确保这些内容只计算一次然后缓存起来,并不再更新. ( 正常情况下不会用到 ) 过渡 transition哪些组件/元素可以用? 条件渲染 (使用 v-if) 条件展示 (使用 v-show) 动态组件 组件根节点 过渡类 v-enter：定义进入过渡的开始状态。 v-enter-active：定义进入过渡生效时的状态。 v-enter-to: 定义进入过渡的结束状态。 v-leave: 定义离开过渡的开始状态。 v-leave-active：定义离开过渡生效时的状态。 v-leave-to: 定义离开过渡的结束状态。 对于这些在过渡中切换的类名来说，如果你使用一个没有名字的 ，则 `v-` 是这些类名的默认前缀。如果你使用了，那么 v-enter 会替换为 my-transition-enter。 过渡模式 in-out：新元素先进行过渡，完成之后当前元素过渡离开。 out-in：当前元素先进行过渡，完成之后新元素过渡进入。 1&lt;transition name="fade" mode="out-in"&gt; &lt;!-- ... the buttons ... --&gt; &lt;/transition&gt; 自定义过渡类名 enter-class enter-active-class enter-to-class leave-class leave-active-class leave-to-class 123456789101112&lt;transition v-on:before-enter="beforeEnter" v-on:enter="enter" v-on:after-enter="afterEnter" v-on:enter-cancelled="enterCancelled" v-on:before-leave="beforeLeave" v-on:leave="leave" v-on:after-leave="afterLeave" v-on:leave-cancelled="leaveCancelled"&gt; &lt;!-- ... --&gt;&lt;/transition&gt; 渲染函数&amp;JSX感觉好菜啊!读到这里发现读完之后没有什么GET到的点,做个记录,之后再返回来细细品一下.👉🏻link 插件看到这里才发现新大陆👉🏻link, 以后要写一个自己的插件出来 Over前前后后花了将近一周,终于将Vue的文档重新过了一遍, 确实, 收获还是蛮多的. 在平常项目开发中, 有许多的东西并不会真切的用到, 但是知识储备还是必须的. 这样在项目中遇到问题之后, 会有自己的一个思路, 从而可以更快的追溯到问题的根源. 继续努力!]]></content>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SEO你的HEXO博客]]></title>
    <url>%2Farchives%2Fa6b6c05e.html</url>
    <content type="text"><![CDATA[STEP1 百度收录站点登录百度站长平台，在用户中心 =&gt; 站点管理添加你的站点网址 配置完站点属性后，进入最后一步：验证网站。有三种方式：文件验证、HTML标签验证、CNAME验证.( 这里如果不会自行百度一下吧,网上内容有很多,这里就不在累述了. ) STEP2 keywords 和 url地址栏优化 在根目录和themes目录下的两个_config.yml文件下找到permalink将其修改为下面这样: 123456# permalink: :year/:month/:day/:title/permalink: archives/:abbrlink.htmlpermalink_defaults:abbrlink: alg: crc32 # 算法：crc16(default) and crc32 rep: hex 安装相关的依赖 1npm install hexo-abbrlink -S 执行hexo部署命名 12hexo ghexo d 完成! STEP3 配置百度 主动推送 自动推送 和sitemap 安装相关依赖 123npm install hexo-baidu-url-submit -Snpm install hexo-generator-sitemap -Snpm install hexo-generator-baidu-sitemap -S 主动推送和sitemap的配置 1234567891011121314deploy:- type: baidu_url_submitter ## 这是新加的 bucket: tomatoro.cn ## 你自己的域名sitemap: path: sitemap.xmlbaidusitemap: path: baidusitemap.xmlbaidu_url_submit: count: 100 ## 比如3，代表提交最新的三个链接 host: tomatoro.cn ## 在百度站长平台中注册的域名 token: --------- ## 请注意这是您的秘钥，请不要发布在公众仓库里! path: baidu_urls.txt ## 文本文档的地址，新链接会保存在此文本文档里 自动推送的代码粘贴到相应的位置即可 1234567891011121314&lt;script&gt; (function()&#123; var bp = document.createElement('script'); var curProtocol = window.location.protocol.split(':')[0]; if (curProtocol === 'https') &#123; bp.src = 'https://zz.bdstatic.com/linksubmit/push.js'; &#125; else &#123; bp.src = 'http://push.zhanzhang.baidu.com/push.js'; &#125; var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(bp, s); &#125;)();&lt;/script&gt; 执行hexo部署命令 12hexo ghexo d 将这些配置全部走完一遍之后, 你博客的SEO优化就算完成了, 在百度上去搜可以发现可以很轻松的搜索到你的博客. 但是, 请记住SEO是一条漫长的道路, 并不是一天就能实现网站排名靠前的, 需要你不断的更新高质量多的博文, 吸引流量才可以. 大功告成!]]></content>
      <tags>
        <tag>Blog</tag>
        <tag>SEO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Notion绑定域名-你的笔记就是你的博客!]]></title>
    <url>%2Farchives%2Fc60ac904.html</url>
    <content type="text"><![CDATA[为Notion公共页面提供自定义域名可能是最受要求的功能之一，而且目前看起来还不支持这样做（可以理解）但是，这里有一个使用Cloudflare Workers的解决方案。 第一步: 将你的域名服务器代理至CloudflareCloudflare需要控制您的DNS，因此请按照本指南将名称服务器切换到它们。不用担心，您的DNS设置将保持不变。 Changing your domain nameservers to Cloudflare 这一步很重要,大致可以理解为以下步骤: 将你原来的nameservers更改为Cloudflare提供给你的nameserver 比如我的域名是在阿里云的, 进行如下操作即可(修改后需要过一段时间等Cloudflare发邮箱给你) 在域名解析里添加一条A的记录,IP随便填 当收到邮件后,你的Cloudflare的Overview页会变成这样,就说明更改nameservers成功了 在Cloudflare的DNS页里也添加一条A的记录,IP随便填但是要保证Proxy Status是通的 第二步: 添加工程脚本Big thanks to Mayne for writing this worker script. You can find the original in this gist. 以下是为你代理域的代码，因此请执行以下操作： Click on the ”Workers” tab Click “Launch Editor” On the left, click ”Add Script” Name it notion-worker Once you have followed those steps, copy this script into that new file. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374const MY_DOMAIN = "example.com"const START_PAGE = "https://www.notion.so/link/to/your/public/page"addEventListener('fetch', event =&gt; &#123; event.respondWith(fetchAndApply(event.request))&#125;)const corsHeaders = &#123; "Access-Control-Allow-Origin": "*", "Access-Control-Allow-Methods": "GET, HEAD, POST,PUT, OPTIONS", "Access-Control-Allow-Headers": "Content-Type",&#125;function handleOptions(request) &#123; if (request.headers.get("Origin") !== null &amp;&amp; request.headers.get("Access-Control-Request-Method") !== null &amp;&amp; request.headers.get("Access-Control-Request-Headers") !== null) &#123; // Handle CORS pre-flight request. return new Response(null, &#123; headers: corsHeaders &#125;) &#125; else &#123; // Handle standard OPTIONS request. return new Response(null, &#123; headers: &#123; "Allow": "GET, HEAD, POST, PUT, OPTIONS", &#125; &#125;) &#125;&#125;async function fetchAndApply(request) &#123; if (request.method === "OPTIONS") &#123; return handleOptions(request) &#125; let url = new URL(request.url) let response if (url.pathname.startsWith("/app") &amp;&amp; url.pathname.endsWith("js")) &#123; response = await fetch(`https://www.notion.so$&#123;url.pathname&#125;`) let body = await response.text() try &#123; response = new Response(body.replace(/www.notion.so/g, MY_DOMAIN).replace(/notion.so/g, MY_DOMAIN), response) // response = new Response(response.body, response) response.headers.set('Content-Type', "application/x-javascript") console.log("get rewrite app.js") &#125; catch (err) &#123; console.log(err) &#125; &#125; else if ((url.pathname.startsWith("/api"))) &#123; response = await fetch(`https://www.notion.so$&#123;url.pathname&#125;`, &#123; body: request.body, // must match 'Content-Type' header headers: &#123; 'content-type': 'application/json;charset=UTF-8', 'user-agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.103 Safari/537.36' &#125;, method: "POST", // *GET, POST, PUT, DELETE, etc. &#125;) response = new Response(response.body, response) response.headers.set('Access-Control-Allow-Origin', "*") &#125; else if (url.pathname === `/`) &#123; let pageUrlList = START_PAGE.split("/") let redrictUrl = `https://$&#123;MY_DOMAIN&#125;/$&#123;pageUrlList[pageUrlList.length-1]&#125;` return Response.redirect(redrictUrl, 301) &#125; else &#123; response = await fetch(`https://www.notion.so$&#123;url.pathname&#125;$&#123;url.search&#125;`, &#123; body: request.body, // must match 'Content-Type' header headers: request.headers, method: request.method, // *GET, POST, PUT, DELETE, etc. &#125;) &#125; return response&#125; 现在，你已经添加了脚本，您需要更改顶部的两个const： MY_DOMAIN 表示你需要代理的域名-你自己的域名 ( E.G. example.com) START_PAGE 表示你代理的目标域名地址-notion的地址(E.G.https://www.notion.so/link/to/your/public/page) 保存你的脚本,然后返回上一层 第三步: 添加一个通配符路径才处理你的所有流量 在这里添加你的域名和通配符,然后在你Worker这一栏选择你刚刚配置的脚本名就可以了 example.com/*到这里为止就大功告成了! 这时候你访问你自己的域名就可以看到notion的页面啦, 以后用notion写博客也可以使用自己的域名了, 可谓是相当酷炫了! 💎最后,这里有我的示例tomatoro.space]]></content>
      <tags>
        <tag>Blog</tag>
        <tag>Notion</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nginx常用命令]]></title>
    <url>%2Farchives%2F96d8af1a.html</url>
    <content type="text"><![CDATA[启动nginx 1nginx 关闭nginx 1nginx -s stop 退出nginx 1nginx -s quit 重启nginx 1nginx -s reload 使用brew下载nginx 1brew install nginx 查看目前执行的任务 1brew services list 进入nginx 文件 1cd /usr/local/etc/nginx 查看nginx的配置 1vi nginx.conf 查看nginx配置有没有生效 12345nginx -tnginx: the configuration file /usr/local/etc/nginx/nginx.conf syntax is oknginx: configuration file /usr/local/etc/nginx/nginx.conf test is successful 启动nginx服务 1brew services start nginx 重启nginx服务 1brew services restart nginx 停止nginx服务 1brew services stop nginx 查看是否启动 1234567ps -ef|grep nginx0 63206 1 0 5:21下午 ?? 0:00.00 nginx: master process nginx-2 63274 63206 0 5:23下午 ?? 0:00.01 nginx: worker process501 65848 62966 0 5:52下午 ttys001 0:00.00 grep --color=auto --exclude-dir=.bzr --exclude-dir=CVS --exclude-dir=.git --exclude-dir=.hg --exclude-dir=.svn nginx 停止当前master的服务 1sudo kill -QUIT 63206]]></content>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git在团队中的最佳实践]]></title>
    <url>%2Farchives%2Ff33d987.html</url>
    <content type="text"><![CDATA[Git Flow常用的分支 Production 分支 也就是我们经常使用的Master分支，这个分支最近发布到生产环境的代码，最近发布的Release， 这个分支只能从其他分支合并，不能在这个分支直接修改 Develop 分支 这个分支是我们是我们的主开发分支，包含所有要发布到下一个Release的代码，这个主要合并与其他分支，比如Feature分支 Feature 分支 这个分支主要是用来开发一个新的功能，一旦开发完成，我们合并回Develop分支进入下一个Release Release分支 当你需要一个发布一个新Release的时候，我们基于Develop分支创建一个Release分支，完成Release后，我们合并到Master和Develop分支 Hotfix分支 当我们在Production发现新的Bug时候，我们需要创建一个Hotfix, 完成Hotfix后，我们合并回Master和Develop分支，所以Hotfix的改动会进入下一个Release Git Flow如何工作初始分支所有在Master分支上的Commit应该Tag Feature 分支分支名 feature/* Feature分支做完后，必须合并回Develop分支, 合并完分支后一般会删点这个Feature分支，但是我们也可以保留 Release分支分支名 release/* Release分支基于Develop分支创建，打完Release分之后，我们可以在这个Release分支上测试，修改Bug等。同时，其它开发人员可以基于开发新的Feature (记住：一旦打了Release分支之后不要从Develop分支上合并新的改动到Release分支) 发布Release分支时，合并Release到Master和Develop， 同时在Master分支上打个Tag记住Release版本号，然后可以删除Release分支了。 维护分支 Hotfix分支名 hotfix/* hotfix分支基于Master分支创建，开发完后需要合并回Master和Develop分支，同时在Master上打一个tag Git Flow代码示例a. 创建develop分支 12git branch developgit push -u origin develop b. 开始新Feature开发 12345678git checkout -b some-feature develop# Optionally, push branch to origin:git push -u origin some-feature # 做一些改动 git statusgit add some-filegit commit c. 完成Feature 1234567891011# 合并feature到devgit pull origin developgit checkout developgit merge --no-ff some-featuregit push origin develop# 删除本地featuregit branch -d some-feature# 删除远端featuregit push origin --delete some-feature d. 开始Relase（test分支） 1234git checkout -b release-0.1.0 develop# Optional: Bump version number, commit# Prepare release, commit e. 完成Release 12345678910111213141516171819# 合并到mastergit checkout mastergit merge --no-ff release-0.1.0git push#合并到devgit checkout developgit merge --no-ff release-0.1.0git push# 删除本地releasegit branch -d release-0.1.0# 删除远端releasegit push origin --delete release-0.1.0 # master打标记git tag -a v0.1.0 mastergit push --tags f. 开始Hotfix（bugfix分支） 1git checkout -b hotfix-0.1.1 master g. 完成Hotfix 12345678910111213141516# 合并到mastergit checkout mastergit merge --no-ff hotfix-0.1.1git push# 合并到devgit checkout developgit merge --no-ff hotfix-0.1.1git push# 删除本地hotfixgit branch -d hotfix-0.1.1# 为本次bug修改打标记git tag -a v0.1.1 mastergit push --tags]]></content>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node学习笔记01]]></title>
    <url>%2Farchives%2Fd57ffb29.html</url>
    <content type="text"><![CDATA[我在做什么, 我拿时间换了什么… —me 九月计划—每天利用下班后的两个学习把Node啃掉! 这是我的学习笔记, 希望这可以做为一个坚持下去的动力! 前言Nodejs 能够做什么，可以解决一些什么样的问题，它的使用场景…如果你有兴趣，请记住一定要自己动手，哪怕照着实例写一遍，真真实实的感受代码运行时的喜悦与兴奋，激发自己对新领域的兴趣。 默认你已经安装了 Nodejs 和 npm 包管理器，并且熟悉一些简单的操作，如 nodejs 代码的运行启动，npm 包的安装命令等基础操作。 第一个服务端应用1. hello world首先通过一个前端工程师最常接触却不属于前端范畴的内容去了解一下 Nodejs，创建一个 http 服务。这里使用 Nodejs 自带的 http 模块创建一个 http 服务，你可以使用通过浏览器或者命令行来发起一个 http 请求，直观的感受服务端的 JavaScript。 12345678// http.jsconst http = require('http')http.createServer((req,res)=&gt;&#123; res.end('Hello World !')&#125;).listen(8000,()=&gt;&#123; consoloe.log('listen on 8000')&#125;) 上面的例子中，通过使用 node 自带的 http 模块，调用其 http.creatServer 方法在本机上开启了一个 http 服务，监听了本地的 8000 端口，代码逻辑很简单，当接收到一个 req 请求时，调用 res.end 返回一个字符串 “hello world” 给带客户端，旨在让你对 Nodejs 有一个直观的体验。 可以使用 node http.js 命令来执行这段代码，通过浏览器来访问 http://127.0.0.1:8000 或者 http://localhost:800 来查看结果。 一个由 Nodejs 的 http 服务提供的 hello world 跑起来了，简洁快速吧。接下来再来实现一个前端工作中与服务端最紧密的内容来看看 Nodejs 的魅力，数据接口。 2. 如何提供一个 API首先这里确定所要提供的 api 是我们最常用的 json 格式，所以我们要注意后端返回给前端的数据类型。 1234567891011121314const http = require('http');const data = &#123; name: 'Nodejs 入门示例', description: '这是返回信息的描述内容', date: new Date()&#125;;http.createServer((req,res)=&gt;&#123; res,setHeader('Content-Type', 'application/json;charset=utf-8') const result = JSON.stringify(data) res.end(result)&#125;).listen(8000, ()=&gt;&#123; console.log('listen on 8000')&#125;) 上例子中，先确定了一个数据模型 data，内部一共有三个字段。这里的数据模型就是前端开发前与后端所定义的返回格式，最终前端要拿到这个 JSON 格式的数据在客户端进行处理。代码逻辑相比于 Hello World，规定了返回的数据格式，以及设定了返回请求的文本类型为 application/json，然后调用 res.end 返回到客户端。 可以继续使用浏览器发起 http 请求来查看结果，一个简单且熟悉的 JSON 数据接口已经完成了。你可以按照前端最常用的调用方式，如 ajax 或者 axios 来请求接口来在你的前端项目使用它。 但是上面例子中的接口和我们常用的接口有一个差异点，就是接口名称和返回内容均不规范，使用者直接通过没有路径的 http://127.0.0.1:8000 来使用接口，这跟我们日常使用的接口是完全不一样的，那我们接下来再看一下如何给提供一个规范化的接口呢？ 3. 一个规范的接口规范的接口具备哪些条件呢？简单总结一下。 接口名称：接口名称要体现出大致的使用场景，例如增删改查的动作。 接口返回：接口返回要有规范化的标识，如成功与否错误内容等。 接下来通过上面这两个点，按照标准的接口规范来实现一下上面的接口，看看 Nodejs 是如何给前端提供接口的。这里先约定要提供的接口名称内含 api 标志，api 所要做的动作等一些关键信息。如下格式： http://localhost:8000/api/search/data?userId=12345 123456789101112131415161718192021222324252627282930313233const http = require('http')const url = require('url')const qs = require('quertstring')// 生成一段返回值const getResponse = userId =&gt;(&#123; success: true, data: &#123; userId, name: 'NodeJS', description: '这是返回的信息', date: new Date() &#125;&#125;)// http 服务http.creatServer((req,res)=&gt;&#123; res.setHeader = ('Content-Type', 'application/json;charset=utf-8') const reqUrl = url.parse(req.url) // 判断接口路径是否是约定好的 if(reqUrl.pathname === 'api/search/data')&#123; // 获取链接上传来的URL参数 const uid = qs.parse(reqUrl.query).userId // 生成返回值 const result = JSON.stringify(getResponse(uid)) res.end(result) &#125;else&#123; res.writeHead(404) res.end('NotFund') &#125;&#125;).listen(8000,()=&gt;&#123; console.log('listen on 8000')&#125;) 上面的例子中，新使用 Nodejs 另一个自带的模块 url，url 模块顾名思义是一个处理 href 的库，它将 href 拆分成各个子内容，同时为了能处理客户端带来的 userId 参数还使用了自带的 querystring 模块，它可以将链接上问号后的 query 参数获取到，以便服务端代码能使用他们，他们均属于工具库，下面看看官方对于 URL 模块将 href 拆分的颗粒度图，清晰的了解一下一个请求链接，可以被拆分成什么颗粒度。 实例中的源码简单解析一下，当服务接收到请求时，先判断请求的 api 名称是不是事先约定好的 / api/search/data，判断通过后，将前端传递在链接上的参数 userId 获取到，处理后插入到返回的 json 数据中，即可通过 res.end 来下发数据，如果路径判断失败，则返回 404 的状态码，并且进入 Notfund 页面， 一个规范的接口已经开发完成了，简单总结一下，上面以渐进式的方式了解了 Nodejs 如何给前端来提供一个规范化的 http 接口，了解了服务端的 JavaScript 所具备的能力，接下来再从另一个前端工程师比较少接触的内容——文件操作，来进一步了解 Nodejs。 文件操作那些事对于文件操作相关的内容，前端程序员一般是不会触及的，而且 JavaScript 语言本身也并没有暴露操作文件的方法。而在 Nodejs 中，本身便提供了 fs 文件操作模块，这个模块模块底层并不是 JavaScript 来编写的，是具备操作文件的 C++ 语言编写的，其封装完成后将上层暴露给 Nodejs，然后便可以使用 JavaScript 的语法来调用它。 1. 读一个文件在 Nodejs 中，读文件有两种形式，一种是同步的另一种是异步的，同步可以理解为读文件这个过程要等待，就是一旦执行的读这个操作的时候，你的代码就被” 卡 “住了，直到文件读完才能继续执行，来看看下面的例子。 先新增一个 test.md 文件配合读操作，文件内容为：### 我是一个文件 123456// fsread.jsconst fs = require('fs');const file = fs.readFileSync('./test.md', 'utf8');console.log(file); 使用 node fsread.js 来运行上面的代码，从上面简单的几行你就可以发现成功将 test.md 文件里的内容读出来，可以打印到了命令行 console 里，突然发现 JavaScript 语言的强大了吧，很神奇吧。 但是 Nodejs 天生是为异步而生的，所以必须要体验一下异步读文件是怎么的过程，与同步的表现有何异同。所以 下面示例一个异步回调的方式去读一个文件，异步的意思就是读文件这个操作进行的同时，读操作下面的 JavaScript 代码也在执行，就如同我们熟悉的软件后台运行一样，你可以继续你的桌面操作。 1234567891011121314151617const fs = require('fs');console.log('sync start');fs.readFile('./test.md', 'utf8', (err, data) =&gt; &#123; console.log('test.md 的内容'); console.log(data);&#125;);console.log('sync progress');fs.readFile('./test2.md', 'utf8', (err, data) =&gt; &#123; console.log('test2.md 的内容'); console.log(data);&#125;);console.log('sync finish'); 在上面的例子中，要求是一次读取两个文件，两个文件之间并没有相关依赖性，所以这种 场景下我们更希望他们各做各的，无需去等。所以没有必要像上面同步的方式，等第一个结束再进入第二个的读取，所以使用异步方式更合适。 从上面的执行结果也可以看出来，fs.readFile 这个异步回调操作均在三个同步代码 console 的后面，并没有像同步等待读操作的结束。 下面来个图看看这个同步 API 和异步 API 有何异同。 图片上半部分是异步读文件，可以看出来，读的操作可以理解为同时刻执行的。 图片下半部分是同步读文件，第二个读的操作需要先等待第一个读完才可以。 举个现实生活中同步的场景，运动会接力赛，A,B 两个班比赛接力，虽然 A,B 两个班无依赖，但是 A 班的第二名同学则需要第一名同学的接力棒拿到后才可继续跑，此时 A 班的运动员之间就属于同步阻塞类型。 在举个异步的场景，老板通过全员会议下达了一个任务，任务是大家做一百个俯卧撑，谁先做完任务则可以领取 10000 元红包的奖励，大家听到后纷纷原地做起，在这时候各个员工之间就是异步的，他们各做各的，谁先做完就可以执行老板给他们的开始说的领取奖励操作，这个操作可以理解为异步回调函数。 2. 写一个文件Nodejs 写文件也是有两个类型，同步与异步，实际执行流程与上面的 “读” 是一样的。 下面进入同步读文件的例子，执行下面的代码你会发现多了一个 test3.md 文件，并且写入’### 我是测试文件 test3’的内容 1234const fs = require('fs');const body = '### 我是测试文件test3的内容';fs.writeFileSync('./test3.md', body); 再来看一下异步写一个文件的例子，做一个对比。 1234567891011121314// 来一个异步的看看。const fs = require('fs');const body = '### 我是测试文件test4的内容';fs.writeFile('./test4.md', body, (err) =&gt; &#123; if (err) throw err; console.log('文件test4已被保存');&#125;);const body2 = '### 我是测试文件test5的内容';fs.writeFile('./test5.md', body2, (err) =&gt; &#123; if (err) throw err; console.log('文件test5已被保存');&#125;); 这是写文件的结果，这时候你的本地会多出两个文件 test4.md 和 test5.md 出来。 3. 其他文件操作其实 Nodejs 提供了丰富的文件操作接口，除了读写，还有像复制，给文件授权，删除一个文件，文件夹的操作，文件内容的监听等，如果你有对文件的操作需求，请先在文档查一下看是否能够满足你。 文档地址：http://nodejs.cn/api/fs.html 下面来一个文件内容监听的例子，带你看看一个文件变化时也能被观察到乐趣。 12345678const fs = require('fs');fs.watch('./test6.md', 'utf8', (eventType, filename)=&gt;&#123; // eventType 是 'rename' 或 'change'， // filename 是触发事件的文件的名称 console.log('eventType', eventType); console.log('filename', filename);&#125;); 我将 test6.md 的内容进行手动的变化，并且改了名字，这里都被监听到了，是不是很有趣，跟我一起来练习吧。 总结本文从前端工程师们最常接触却又不属于前端领域的两个方面，http 服务与文件操作展开了学习，从几个简单易懂的例子带领去了解了 Nodejs。其实Node非诚简单便捷，几行代码就能做出一些想要的效果，能快速的完成要求。]]></content>
      <tags>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git worktree 的使用]]></title>
    <url>%2Farchives%2Fa2d3386.html</url>
    <content type="text"><![CDATA[适用场景 在同一个 git 仓库中，有时候会遇到这样的情况, 你将你分支的代码开发好了,正在运行代码测试. 这时候你接到一个任务–&gt;主分支上有一个bug需要立刻处理. 而你的代码测试已经跑了一大半了, 你不想结束这个测试, 但还必须去主分支上修改这个BUG, 这时候git stash的暂存明显是不能用的, 而重新clone一个新的项目下来有显得很麻烦. 这时候就是Git WorkTree 大展身手的时候了 git 从 2.6.0 的版本开始增加了新的指令，可以用来解决这个问题，就是： git worktree 一个 git 仓库默认有一个 worktree，当需要在同一个仓库兼顾两个或者多个分支的开发时，可以为每一个分支新建一个 worktree 。他们彼此之间不会相互影响，其表现相当于在一个其他的目录重新 git clone 了一把这个 git 仓库。实际上与重建目录不同的是，他们彼此之间又有关联，任何一个 worktree 的提交都会无痛增加到其他的 worktree ，而不需要通过远程仓库做同步。一个分支的工作结束之后，删除那个分支对应的目录即可关闭这个 worktree。总之就是，看来还算完美的一个解决方案。 常用git worktree add &lt;path&gt; [&lt;branch&gt;]：增加一个新的 worktree ，并指定了其关联的目录是 path ，关联的分支是 &lt;branch&gt; 。后者是一个可选项，默认值是 HEAD 分支。如果 &lt;branch&gt; 已经被关联到了一个 worktree ，则这次 add 会被拒绝执行，可以通过增加 -f | --force 选项来强制执行。 同时，可以使用 -b &lt;new-branch&gt; 基于 &lt;branch&gt; 新建分支并使这个新分支关联到这个新的 worktree 。如果 &lt;new-branch&gt; 已经存在，则这次 add 会被拒绝，可以使用 -B 代替这里的 -b 来强制执行，则原来的 &lt;new-branch&gt; 的提交进度会被重置为和 &lt;branch&gt; 一样的位置。 git worktree list :列出当前仓库已经存在的所有 worktree 的详细情况，包括每个 worktree 的关联目录，当前的提交点的哈希码和当前 checkout 到的关联分支。若没有关联分支，则是 detached HEAD 。 可以增加 --porcelain 选项，用来改变显示风格。即：使用 label 对应 value 的形式显示上面提到的内容。举例容易看出其中差别： 1234$ git worktree list/path/to/bare-source (bare)/path/to/linked-worktree abcd1234 [master]/path/to/other-linked-worktree 1234abc (detached HEAD) 1234567891011$ git worktree list --porcelainworktree /path/to/bare-sourcebare​worktree /path/to/linked-worktreeHEAD abcd1234abcd1234abcd1234abcd1234abcd1234branch refs/heads/master​worktree /path/to/other-linked-worktreeHEAD 1234abc1234abc1234abc1234abc1234abc1234adetached prune :在删除 worktree 的关联目录之后，清除 worktree 的信息。从而使一个 worktree 完整的删除。 其他git worktree lock :git 会定期的自动清除掉已经没有关联目录的那些 worktree 的信息。当你把一个 worktree 的关联目录创建到了一个可移动设备或者一块不是永久挂载的硬盘里的时候，使用这个命令可以防止这个 worktree 的信息被移除。 git worktree unlock :与上面的命令是一对。作用是解除锁定。 总结看起来只是把 git 的文档大概翻译了一下，写一遍加深理解吧。也是刚开始使用的新命令，设计也是很稳重的，没有那么多花哨，没什么好的技巧可谈，但绝对是五星推荐的好用。 参考git worktree]]></content>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git stash 暂存的操作]]></title>
    <url>%2Farchives%2F64676934.html</url>
    <content type="text"><![CDATA[适用场景 我们在多人开发的时候,经常遇到开发某一个分支时,需要处理其他分支的事情. 这时就可以暂存手头的工作,切到其它分支,进行工作. 完事后再接回原来的分支并恢复之前的内容, 继续工作 Cool! 1. 暂存操作12345git status // 查看当前状态git add . // 如果有修改,添加修改文件git stash save '本次暂存的标识名字' // 暂存操作 2. 查看当前暂存的记录1git stash list // 查看记录 3. 恢复暂存的工作 pop命令恢复,恢复后,暂存区域会删除当前的记录 1git stash pop stash@&#123;index&#125; // 恢复指定的暂存工作, 暂存记录保存在list内,需要通过list索引index取出恢复 apply命令恢复,恢复后,暂存区域会保留当前的记录 1git stash apply stash@&#123;index&#125; // 恢复指定的暂存工作, 暂存记录保存在list内,需要通过list索引index取出恢复 4. 删除暂存123git stash drop stash@&#123;index&#125; // 删除某个暂存, 暂存记录保存在list内,需要通过list索引index取出恢复git stash clear // 删除全部暂存]]></content>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【转】为什么我喜欢JavaScript的Optional Chaining]]></title>
    <url>%2Farchives%2Ffafa2f28.html</url>
    <content type="text"><![CDATA[前言 JavaScript 的特性极大地改变了你的编码方式。从 ES2015 开始，对我代码影响最多的功能是解构、箭头函数、类和模块系统。截至 2019 年 8 月，一项新提案 optional chaining 达到了第3阶段，这将是一个很好的改进。Optional Chaining 改变了从深层对象结构访问属性的方式。下面让我们来看看 optional chaining 是如何通过在深度访问可能缺少的属性时删除样板条件和变量来简化代码的。 1. 问题由于 JavaScript 的动态特性，对象可以有区别很大的嵌套对象结构。 通常，你在以下情况下处理此类对象： 获取远程 JSON 数据 使用配置对象 具有 optional 属性 虽然这为对象提供了支持不同结构数据的灵活性，但是在访问这些对象的属性时会增加复杂性。 bigObject 在运行时可以有不同的属性集： 12345678910111213141516171819// One version of bigObjectconst bigObject = &#123; // ... prop1: &#123; //... prop2: &#123; // ... value: 'Some value' &#125; &#125;&#125;;// Other version of bigObjectconst bigObject = &#123; // ... prop1: &#123; // Nothing here &#125;&#125;; 因此，你必须手动检查属性是否存在： 123456// Laterif (bigObject &amp;&amp; bigObject.prop1 != null &amp;&amp; bigObject.prop1.prop2 != null) &#123; let result = bigObject.prop1.prop2.value;&#125; 这会产生很多样板代码。如果不需要写这些代码那就太好了。 让我们看看 optional chaining 如何解决这个问题，并减少样板条件。 2. 轻松的深入访问属性让我们设计一个保存电影信息的对象。该对象包含一个 title 属性，以及可选的 director 和 actors。 movieSmall 对象只包含 title，而 movieFull 包含完整的属性集： 123456789const movieSmall = &#123; title: 'Heat'&#125;;const movieFull = &#123; title: 'Blade Runner', director: &#123; name: 'Ridley Scott' &#125;, actors: [&#123; name: 'Harrison Ford' &#125;, &#123; name: 'Rutger Hauer' &#125;]&#125;; 让我们写一个获取导演名字的函数。请记住，director 属性可能会不存在： 12345678function getDirector(movie) &#123; if (movie.director != null) &#123; return movie.director.name; &#125;&#125;getDirector(movieSmall); // =&gt; undefinedgetDirector(movieFull); // =&gt; 'Ridley Scott' if (movie.director) {...} 条件用于验证 director 属性是否已定义。如果没有这个预防措施，在访问movieSmall 对象 director 的时候，JavaScript 会抛出错误 TypeError: Cannot read property &#39;name&#39; of undefined。 这是使用新的 optional chaining 功能的正确位置，并删除 movie.director 的存在验证。新版本的getDirector()看起来要短得多： 123456function getDirector(movie) &#123; return movie.director?.name;&#125;getDirector(movieSmall); // =&gt; undefinedgetDirector(movieFull); // =&gt; 'Ridley Scott' 在表达式 movie.director?.name 中你可以找到 ?.： optional chaining 运算符。 在 movieSmall 的情况下，如果属性 director 丢失了。那么 movie.director?.name 的计算结果为 undefined。 optional chaining 运算符可防止抛出 TypeError:Cannot read property &#39;name&#39; of undefined。 相反，在 movieFull 的情况下，属性 director 可用。 movie.director?.name 的值为 &#39;Ridley Scott&#39;.。 简单来说，代码片段： 1let name = movie.director?.name; 相当于： 1234let name;if (movie.director != null) &#123; name = movie.director.name;&#125; ?. 通过减少 2 行代码简化了 getDirector() 函数。这就是我喜欢 optional chaining 的原因。 2.1 数组项但是 optional chaining 功能可以做更多的事情。你可以在同一表达式中使用多个 optional chaining 运算符。甚至可以使用它来安全地访问数组项目！ 接下来的任务是编写一个返回电影主角名字的函数。 在 movie 对象中，actors 数组可以为空甚至丢失，因此你必须添加其他条件： 12345678function getLeadingActor(movie) &#123; if (movie.actors &amp;&amp; movie.actors.length &gt; 0) &#123; return movie.actors[0].name; &#125;&#125;getLeadingActor(movieSmall); // =&gt; undefinedgetLeadingActor(movieFull); // =&gt; &apos;Harrison Ford&apos; if (movie.actors &amp;&amp; movies.actors.length &gt; 0) {...} 条件需要确保 movie 中包含 actors 属性，并且此属性至少有一个 actor。 通过使用 optional chaining，此任务很容易解决： 123456function getLeadingActor(movie) &#123; return movie.actors?.[0]?.name;&#125;getLeadingActor(movieSmall); // =&gt; undefinedgetLeadingActor(movieFull); // =&gt; &apos;Harrison Ford&apos; actors?. 确保 actors 属性存在。 [0]?. 确保第一个 actor 存在于列表中。很好！ 3. nullish 合并名为 nullish coalescing operator 的新提案建议用 ?? 处理 undefined或null，将它们默认为特定的值。 如果 variable 是undefined或null，则表达式 variable ?? defaultValue 的结果为defaultValue， 否则表达式的值为variable 的值。 12345const noValue = undefined;const value = &apos;Hello&apos;;noValue ?? &apos;Nothing&apos;; // =&gt; &apos;Nothing&apos;value ?? &apos;Nothing&apos;; // =&gt; &apos;Hello&apos; 当评估为 undefined 时，Nullish 合并可以通过默认值来改进 optional chaining。 例如，当 movie 对象中没有 actor 时，让我们改变 getLeading() 函数返回 &quot;Unknown actor&quot;： 123456function getLeadingActor(movie) &#123; return movie.actors?.[0]?.name ?? &apos;Unknown actor&apos;;&#125;getLeadingActor(movieSmall); // =&gt; &apos;Unknown actor&apos;getLeadingActor(movieFull); // =&gt; &apos;Harrison Ford&apos; 4. optional chaining 的 3 种形式可以用以下 3 种形式使用 optional chaining 。 第一种形式 object?.property 用于访问静态属性： 12const object = null;object?.property; // =&gt; undefined 第二种形式 object？.[expression] 用于访问动态属性或数组项： 123456const object = null;const name = &apos;property&apos;;object?.[name]; // =&gt; undefinedconst array = null;array?.[0]; // =&gt; undefined 最后，第三种形式 object?.([arg1,[arg2,...]]) 执行一个对象方法： 12const object = null;object?.method(&apos;Some value&apos;); // =&gt; undefined 如果需要，可以通过组合这些表单来创建长的可选链： 1const value = object.maybeUndefinedProp?.maybeNull()?.[propName]; 5. 短路：停止于 null/undefined有关 optional chaining 运算符的有趣之处在于，只要在其左侧 leftHandSide?.rightHandSide 中遇到无效值，右侧访问器的评估就会停止。这称为短路。 我们来看一个例子： 12345const nothing = null;let index = 0;nothing?.[index++]; // =&gt; undefinedindex; // =&gt; 0 nothing 保持一个 nullish 值，因此 optional chaining 评估为 undefined ，并跳过右侧访问器的评估。因为 index 编号不会增加。 6. 何时使用 optional chaining一定要克制使用 optional chaining 操作符访问任何类型属性的冲动：这将会导致误导使用。下一节将介绍何时正确使用它。 6.1 访问可能无效的属性?. 必须只在可能无效的属性附近使用：maybeNullish?.prop。在其他情况下，使用旧的属性访问器：.property 或 [propExpression]。 回想一下 movie 对象。查看表达式 movie.director?.name，因 为director 可以是 undefined，在director属性附近使用 optional chaining 运算符是正确的。 相反，使用 ?. 来访问电影标题是没有意义的：movie?.title。movie 对象不会是无效的。 1234567891011121314// Goodfunction logMovie(movie) &#123; console.log(movie.director?.name); console.log(movie.title);&#125;// Badfunction logMovie(movie) &#123; // director needs optional chaining console.log(movie.director.name); // movie doesn&apos;t need optional chaining console.log(movie?.title);&#125; 6.2 通常有更好的选择以下函数 hasPadding() 接受带有可选 padding 属性的样式对象。 padding 具有可选属性left、top、right、bottom。 下面尝试使用 optional chaining 运算符： 1234567891011function hasPadding(&#123; padding &#125;) &#123; const top = padding?.top ?? 0; const right = padding?.right ?? 0; const bottom = padding?.bottom ?? 0; const left = padding?.left ?? 0; return left + top + right + bottom !== 0;&#125;hasPadding(&#123; color: &apos;black&apos; &#125;); // =&gt; falsehasPadding(&#123; padding: &#123; left: 0 &#125; &#125;); // =&gt; falsehasPadding(&#123; padding: &#123; right: 10 &#125;&#125;); // =&gt; true 虽然函数正确地确定元素是否具有填充，但是对于每个属性都使用 optional chaining 是非常困难的。 更好的方法是使用对象扩展运算符将填充对象默认为零值： 1234567891011121314function hasPadding(&#123; padding &#125;) &#123; const p = &#123; top: 0, right: 0, bottom: 0, left: 0, ...padding &#125;; return p.top + p.left + p.right + p.bottom !== 0;&#125;hasPadding(&#123; color: &apos;black&apos; &#125;); // =&gt; falsehasPadding(&#123; padding: &#123; left: 0 &#125; &#125;); // =&gt; falsehasPadding(&#123; padding: &#123; right: 10 &#125;&#125;); // =&gt; true 在我看来，这个版本的 hasPadding() 更容易阅读。 7. 为什么我喜欢它？我喜欢 optional chaining 运算符，因为它允许从嵌套对象轻松访问属性。它可以减少通过编写样板文件来验证来自访问器链的每个属性访问器上无效值的工作。 当 optional chaining 与无效合并运算符组合时，你可以获得更好的结果，能够更轻松地处理默认值。 转载信息作者：Dmitri Pavlutin翻译：疯狂的技术宅原文：https://dmitripavlutin.com/ja…来源：思否]]></content>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【转】网上都说操作真实 DOM 慢，但测试结果却比 React 更快，为什么？]]></title>
    <url>%2Farchives%2F3f0a5b42.html</url>
    <content type="text"><![CDATA[1. 原生 DOM 操作 vs. 通过框架封装操作。这是一个性能 vs. 可维护性的取舍。框架的意义在于为你掩盖底层的 DOM 操作，让你用更声明式的方式来描述你的目的，从而让你的代码更容易维护。没有任何框架可以比纯手动的优化 DOM 操作更快，因为框架的 DOM 操作层需要应对任何上层 API 可能产生的操作，它的实现必须是普适的。针对任何一个 benchmark，我都可以写出比任何框架更快的手动优化，但是那有什么意义呢？在构建一个实际应用的时候，你难道为每一个地方都去做手动优化吗？出于可维护性的考虑，这显然不可能。框架给你的保证是，你在不需要手动优化的情况下，我依然可以给你提供过得去的性能。 2. 对 React 的 Virtual DOM 的误解。React 从来没有说过 “React 比原生操作 DOM 快”。React 的基本思维模式是每次有变动就整个重新渲染整个应用。如果没有 Virtual DOM，简单来想就是直接重置 innerHTML。很多人都没有意识到，在一个大型列表所有数据都变了的情况下，重置 innerHTML 其实是一个还算合理的操作… 真正的问题是在 “全部重新渲染” 的思维模式下，即使只有一行数据变了，它也需要重置整个 innerHTML，这时候显然就有大量的浪费。 我们可以比较一下 innerHTML vs. Virtual DOM 的重绘性能消耗： innerHTML: render html string O(template size) + 重新创建所有 DOM 元素 O(DOM size) Virtual DOM: render Virtual DOM + diff O(template size) + 必要的 DOM 更新 O(DOM change) Virtual DOM render + diff 显然比渲染 html 字符串要慢，但是！它依然是纯 js 层面的计算，比起后面的 DOM 操作来说，依然便宜了太多。可以看到，innerHTML 的总计算量不管是 js 计算还是 DOM 操作都是和整个界面的大小相关，但 Virtual DOM 的计算量里面，只有 js 计算和界面大小相关，DOM 操作是和数据的变动量相关的。前面说了，和 DOM 操作比起来，js 计算是极其便宜的。这才是为什么要有 Virtual DOM：它保证了 1）不管你的数据变化多少，每次重绘的性能都可以接受；2) 你依然可以用类似 innerHTML 的思路去写你的应用。 3. MVVM vs. Virtual DOM相比起 React，其他 MVVM 系框架比如 Angular, Knockout 以及 Vue、Avalon 采用的都是数据绑定：通过 Directive/Binding 对象，观察数据变化并保留对实际 DOM 元素的引用，当有数据变化时进行对应的操作。MVVM 的变化检查是数据层面的，而 React 的检查是 DOM 结构层面的。MVVM 的性能也根据变动检测的实现原理有所不同：Angular 的脏检查使得任何变动都有固定的 O(watcher count) 的代价；Knockout/Vue/Avalon 都采用了依赖收集，在 js 和 DOM 层面都是 O(change)： 脏检查：scope digest O(watcher count) + 必要 DOM 更新 O(DOM change) 依赖收集：重新收集依赖 O(data change) + 必要 DOM 更新 O(DOM change) 可以看到，Angular 最不效率的地方在于任何小变动都有的和 watcher 数量相关的性能代价。但是！当所有数据都变了的时候，Angular 其实并不吃亏。依赖收集在初始化和数据变化的时候都需要重新收集依赖，这个代价在小量更新的时候几乎可以忽略，但在数据量庞大的时候也会产生一定的消耗。 MVVM 渲染列表的时候，由于每一行都有自己的数据作用域，所以通常都是每一行有一个对应的 ViewModel 实例，或者是一个稍微轻量一些的利用原型继承的 “scope” 对象，但也有一定的代价。所以，MVVM 列表渲染的初始化几乎一定比 React 慢，因为创建 ViewModel / scope 实例比起 Virtual DOM 来说要昂贵很多。这里所有 MVVM 实现的一个共同问题就是在列表渲染的数据源变动时，尤其是当数据是全新的对象时，如何有效地复用已经创建的 ViewModel 实例和 DOM 元素。假如没有任何复用方面的优化，由于数据是 “全新” 的，MVVM 实际上需要销毁之前的所有实例，重新创建所有实例，最后再进行一次渲染！这就是为什么题目里链接的 angular/knockout 实现都相对比较慢。相比之下，React 的变动检查由于是 DOM 结构层面的，即使是全新的数据，只要最后渲染结果没变，那么就不需要做无用功。 Angular 和 Vue 都提供了列表重绘的优化机制，也就是 “提示” 框架如何有效地复用实例和 DOM 元素。比如数据库里的同一个对象，在两次前端 API 调用里面会成为不同的对象，但是它们依然有一样的 uid。这时候你就可以提示 track by uid 来让 Angular 知道，这两个对象其实是同一份数据。那么原来这份数据对应的实例和 DOM 元素都可以复用，只需要更新变动了的部分。或者，你也可以直接 track by $index 来进行 “原地复用”：直接根据在数组里的位置进行复用。在题目给出的例子里，如果 angular 实现加上 track by $index 的话，后续重绘是不会比 React 慢多少的。甚至在 dbmonster 测试中，Angular 和 Vue 用了 track by $index 以后都比 React 快。 顺道说一句，React 渲染列表的时候也需要提供 key 这个特殊 prop，本质上和 track-by 是一回事。 4. 性能比较也要看场合在比较性能的时候，要分清楚初始渲染、小量数据更新、大量数据更新这些不同的场合。Virtual DOM、脏检查 MVVM、数据收集 MVVM 在不同场合各有不同的表现和不同的优化需求。Virtual DOM 为了提升小量数据更新时的性能，也需要针对性的优化，比如 shouldComponentUpdate 或是 immutable data。 初始渲染：Virtual DOM &gt; 脏检查 &gt;= 依赖收集 小量数据更新：依赖收集 &gt;&gt; Virtual DOM + 优化 &gt; 脏检查（无法优化） &gt; Virtual DOM 无优化 大量数据更新：脏检查 + 优化 &gt;= 依赖收集 + 优化 &gt; Virtual DOM（无法/无需优化）&gt;&gt; MVVM 无优化 不要天真地以为 Virtual DOM 就是快，diff 不是免费的，batching 么 MVVM 也能做，而且最终 patch 的时候还不是要用原生 API。在我看来 Virtual DOM 真正的价值从来都不是性能，而是它 为函数式的 UI 编程方式打开了大门； 可以渲染到 DOM 以外的 backend，比如 ReactNative。 5. 总结以上这些比较，更多的是对于框架开发研究者提供一些参考。主流的框架 + 合理的优化，足以应对绝大部分应用的性能需求。如果是对性能有极致需求的特殊情况，其实应该牺牲一些可维护性采取手动优化：比如 Atom 编辑器在文件渲染的实现上放弃了 React 而采用了自己实现的 tile-based rendering；又比如在移动端需要 DOM-pooling 的虚拟滚动，不需要考虑顺序变化，可以绕过框架的内置实现自己搞一个。 转载信息作者：尤雨溪链接：https://www.zhihu.com/question/31809713/answer/53544875来源：知乎]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用优雅的方式进行数组去重]]></title>
    <url>%2Farchives%2F9c7dd70f.html</url>
    <content type="text"><![CDATA[想必,数组去重已经是一个老生常谈的问题了, 到现在为止我们要考虑的并不是怎么去实现一个数组去重, 而更应该关注,怎样使用一段更短的代码, 更优雅, 更简洁的达到我们想要的效果. 开篇 我们这里直接列出三种比较优雅的数组去重的方法,在后面对每个进行详细的解析 1234567const originalArray = [1, 2, '咩', 1, 'Super Ball', '咩', '咩', 'Super Ball', 4]const bySet = [...new Set(originalArray)]const byFilter = originalArray.filter((item, index) =&gt; originalArray.indexOf(item) === index)const byReduce = originalArray.reduce((unique, item) =&gt; unique.includes(item) ? unique : [...unique, item], []) Set先让我们来看看 Set 到底是个啥 Set 对象允许你存储任何类型的唯一值，无论是原始值或者是对象引用。https://developer.mozilla.org… 首先， Set 中只允许出现唯一值唯一性是比对原始值或者对象引用 const bySet = [...new Set(originalArray)]这一段的操作，我们将它拆分来看： 1234567const originalArray = [1, 2, '咩', 1, 'Super Ball', '咩', '咩', 'Super Ball', 4]const uniqueSet = new Set(originalArray)// 得到 Set(5) [ 1, 2, "咩", "Super Ball", 4 ]const bySet = [...uniqueSet]// 得到 Array(5) [ 1, 2, "咩", "Super Ball", 4 ] 在将 Set 转为 Array 时，也可以使用 Array.from(set)。 Array.prototype.filter要理解 filter 方法为什么可以去重，需要关注一下另一个方法 indexOf indexOf()方法返回在数组中可以找到一个给定元素的第一个索引，如果不存在，则返回 -1。https://developer.mozilla.org… 1234567891011const beasts = ['ant', 'bison', 'camel', 'duck', 'bison'];console.log(beasts.indexOf('bison'));// expected output: 1// start from index 2console.log(beasts.indexOf('bison', 2));// expected output: 4console.log(beasts.indexOf('giraffe'));// expected output: -1 filter() 方法创建一个新数组, 其包含通过所提供函数实现的测试的所有元素。https://developer.mozilla.org… filter 方法接受两个参数： 第一个参数：一个回调函数， filter 会将数据中的每一项都传递给该函数，若该函数返回 真值，则数据保存，返回 假值，则数据将不会出现在新生成的数据中 第二个参数：回调函数中 this 的指向 我们将上面的去重方法按下面这样重写一下，就可以看清整个 filter 的执行过程了。 1234567891011121314151617const originalArray = [1, 2, '咩', 1, 'Super Ball', '咩', '咩', 'Super Ball', 4]const table = []const byFilter = originalArray.filter((item, index) =&gt; &#123; // 如果找到的索引与当前索引一致，则保留该值 const shouldKeep = originalArray.indexOf(item) === index table.push(&#123; 序号: index, 值: item, 是否应该保留: shouldKeep ? '保留' : '删除' &#125;) return shouldKeep&#125;)console.log(byFilter)console.table(table) 序号 值 是否应该保留 出现 0 1 保留 第一次出现 1 2 保留 第一次出现 2 咩 保存 第一次出现 3 1 删除 第二次出现 4 Super Ball 保留 第一次出现 5 咩 删除 第二次出现 6 咩 删除 第三次出现 7 Super Ball 删除 第二次出现 8 4 保留 第一次出现 Array.prototype.reduce reduce() 方法对数组中的每个元素执行一个由您提供的 reducer 函数(升序执行)，将其结果汇总为单个返回值。https://developer.mozilla.org… Array.prototype.reduce 方法接受两个参数： Callback：回调函数，它可以接收四个参数 Accumulator：累计器，这个其实是让很多人忽略的一点，就是，累计器其实可以是任何类型的数据 Current Value：当前值 Current Index：当前值的索引 Source Array：源数组 Initial Value：累计器的初始值，就跟累计器一样，这个参数也总是被绝大多数人忽略 就像 filter 章节一样，我们来看看 reduce 的执行过程： 12345678910111213const originalArray = [1, 2, '咩', 1, 'Super Ball', '咩', '咩', 'Super Ball', 4]const byReduce = originalArray.reduce((unique, item, index, source) =&gt; &#123; const exist = unique.includes(item) const next = unique.includes(item) ? unique : [...unique, item] console.group(`遍历第 $&#123;index&#125; 个值`) console.log('当前累计器：', unique) console.log('当前值：', item) console.log('是否已添加进累计器？', exist) console.log('新值', next) console.groupEnd() return next&#125;, [])]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何在一台设备上同时配置github和gitlab的SSH]]></title>
    <url>%2Farchives%2Fd97dbbe6.html</url>
    <content type="text"><![CDATA[背景 在工作中，很有可能遇到这样的情况：公司用gitlab搭建了一个仓库，自己平常使用github来存储自己的代码。这样就造成在只设置了公司的gitlab SSH的时候，clone自己github仓库代码时，只能使用HTTPS的方式clone，很不方便。所以这篇文章会教会你同时在一台电脑上配置两个SSH，以方便自己在工作和个人空间上的快速切换，提高效率。 正文首先，要找到位于用户下的.ssh文件，直接： 1cd ~/.ssh 然后, 需要设置全局的name和email(这里注意,哪个常用设置哪个,我是公司常用,就设置的公司的) 12git config --global user.name 'xxx'git config --global user.email 'xxx@baijia.com' 接下来, 开始生成秘钥文件. 这里直接两个都生成一下 1234ssh-keygen -t rsa -C 'xxx@bai'jia.com' // GitLab// Enter file in which to save the key (/Users/tomatoro/.ssh/id_rsa): id_rsa_gitlabssh-keygen -t rsa -C 'tomatoro@163.com' // GitHub// Enter file in which to save the key (/Users/tomatoro/.ssh/id_rsa): id_rsa_github 进入到.ssh文件下,找到id_rsa_gitlab.pub和id_rsa_github.pub 将里面的内容全部复制粘贴到github 和 gitlab 的SSHKEY上 12cat id_rsa_gitlab.pubcat id_rsa_github.pub 这里名字随便起, 然后记得.pub文件里内容全部复制就好了. 完了之后点保存. gitlab同理. 接下来就要将两个key在本地存储起来打开agent 123ssh-agent -sssh-add ~/.ssh/id_rsa_github // 输入生成秘钥时设置的密码ssh-add ~/.ssh/id_rsa_gitlab // 输入生成秘钥时设置的密码 然后需要一个config文件来管理这两个key,以让git知道分配给谁在.ssh目录下创建config文件 1touch ~/.ssh/config 打开config编辑如下内容 12345678910111213Host github.com // 不动 HostName github.com // 不动 User tomatoro@163.com // 你自己的github邮箱 PreferredAuthentications publickey // 不动 IdentityFile ~/.ssh/id_rsa_github // 不动 Port 443 // 如果ssh -T git@github.com的时候报 ssh: connect to host github.com port 22: Operation timed out就把Port这条加上吧,这个坑坑了我好久!!Host 192.168.0.231 // 你们公司gitlab的ip地址 HostName 192.168.0.231 //与Host保持一致 User xxx@baijia.com // 你gitlab的邮箱 IdentityFile ~/.ssh/id_rsa_gitlab // 不动 Port 64222 // 你们公司gitlab的ip端口 没有的话可以不写 好了,到了这一步,设置就基本全部完成了,接下来只需要跟远端的SSH同步一下就OK了 公司仓库下 123ssh -T git@192.168.0.231输入密码git clone ssh://git@192.168.0.231:64222/MLE/skillCenter.git 个人仓库下 123456git init // --local需要在有git仓库的情况下才可以执行git config —local user.name 'tomatoro'git config —local user.email 'tomatoro@163.com'ssh -T git@github.com输入密码git clone ssh://git@github.com:443/Tomatoro/TypeScript-study.git 整个流程下来就是这个样子 至此,就全部结束了. 想想我在搞这个东西的时候遇到的坑,现在都觉得好恶心. 整整弄了一下午, 希望对后来者有些许帮助吧.全部原创,欢迎转载!转载请注明出处.谢谢!]]></content>
      <tags>
        <tag>Blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何将个人博客同时部署到GitHub和Coding上]]></title>
    <url>%2Farchives%2F3de92cb5.html</url>
    <content type="text"><![CDATA[前言 之前我们把hexo托管在github，但是毕竟github是国外的，访问速度上还是有点慢，所以想也部署一套在国内的托管平台，下面给大家推荐一个国内代码托管的平台Coding。 可以学到什么 通过这篇文章，我们可以将我们的个人博客同时部署在国内和国外两个节点上。这样，如果是国内访问博客，会自动采用国内的节点，实现快速访问。如果是国外访问博客，便会采用国外的节点，以保证连接的可实现。 正文_config.yml配置 想要同时部署到2个平台，就要修改博客根目录下面的_config.yml文件中的deploy如下根据Hexo官方文档需要修改成下面的形式 123456deploy: type: git repo: github: &lt;repository url&gt; coding: &lt;repository url&gt; branch: [branch] 比如我这样 我这边提交采用的SSH密钥，这个方法有个好处，提交的时候不用输入用户名和密码。如果你习惯用http的方式，只要将地址改成相应的http地址即可。 coding上创建一个新项目 这里只介绍coding上面如何创建项目，以及把本地hexo部署到coding上面，还不懂如何创建hexo的请看我之前的系类文章。首先我们创建一个项目，创建后进入项目的代码模块，获取到这个项目的ssh地址 同步本地hexo到coding上 把获取到了ssh配置在上面的_config.yml文件中的deploy下，本地打开 id_rsa.pub 文件，复制其中全部内容，填写到SSH_RSA公钥key下的一栏，公钥名称可以随意起名字。完成后点击“添加”，然后输入密码或动态码即可添加完成。 添加后，在git bash命令输入： 1ssh -T git@git.coding.net 如果得到下面提示就表示公钥添加成功了： 1Coding.net Tips : [Hello ! You&apos;ve conected to Coding.net by SSH successfully! ] 最后使用部署命令就能把博客同步到coding上面： 1hexo deploy -g pages服务方式部署 部署博客方式有两种，第一种就是pages服务的方式，也推荐这种方式，因为可以绑定域名，而第二种演示的方式必须升级会员才能绑定自定义域名。pages方式也很简单 分支选择master，因为前面配置的分支是master,因此开启之后，也需要是master。然后看起之后就可访问了。 注意： 如果你的项目名称跟你coding的用户名一样，比如我的用户是叫tengj,博客项目名也叫tengj 那直接访问 tengj.coding.me就能访问博客，否则就要带上项目名：tengj.coding.me/项目名 才能访问推荐项目名跟用户名一样，这样就可以省略项目名了 这里需要将自定义域名填上你自己的域名就可以了 SSL/TLS安全证书这里有个坑,就是如果你之前已经创建绑定过github的代码仓库,那么直接生成这个证书是生成不了的,他会显示失败的状态,需要过30分钟才可以再次申请。 所以到这一步的小伙伴，可以先把这一步空下来，继续网下看，会告诉该怎么操作才正确。 个人域名绑定 我是在阿里上买的tomatoro.cn的这个域名，现在要实现国内的走coding，海外的走github，只要配置2个CNAME就行。域名解析如下： 注意：这里就说一下如果之前有设置过github的域名解析, 现在要再绑定一个coding的域名解析, 需要注意的点:在coding去申请 SSL/TLS安全证书之前,需要将图中框起来的两个域名先暂停, 然后, 我们再去申请 SSL/TLS安全证书, 一般只需要等几秒就成功了, 然后再把这两个域名解析驱动就可以了. 一定要注意啊, 我就是因为这个等了半个小时才能接着申请的. 过几分钟后检测tomatoro.cn看到的解析是正确的，国内解析到Coding，国外解析到Github，如图： 总结 到此为止，终于可以实现部署一次，github和coding两个同步都搞定了。访问速度也是唰唰唰的快，希望对还在搭建hexo独立博客的小伙伴有帮助。]]></content>
      <tags>
        <tag>Blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何搭建属于自己的博客]]></title>
    <url>%2Farchives%2Fd2ee919b.html</url>
    <content type="text"></content>
      <tags>
        <tag>Blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tomatoro]]></title>
    <url>%2Farchives%2Fbe5a804b.html</url>
    <content type="text"><![CDATA[前言 这是我本人开始写的第一个博客，在这之前有许多许多次机会来开始这件事情，最开始写自己的文章都是在简书和思否上的。很喜欢看见阅读和点赞数量的增加带来的成就和喜悦感。可终究那不是属于我自己的方寸天地，想静下来，记录记录自己的东西。我不会限制我的博客将来会写哪些东西，技术也好，生活也罢，它都是我忠实的伙伴，伴我成长！ README123456789101112# 开启服务hexo server# 创建一篇文章hexo new '文章标题'# 清除缓存文件 (db.json) 和已生成的静态文件 (public)。hexo clean# 生成静态文件hexo generate / g# 保存自动更新hexo generate -w# 一键部署hexo deploy / d]]></content>
      <tags>
        <tag>Blog</tag>
      </tags>
  </entry>
</search>
